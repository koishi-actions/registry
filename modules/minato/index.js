import{Buffer as Oe}from"https://registry.koishi.chat/modules/buffer/index.js";import je from"https://registry.koishi.chat/modules/process/index.js";import{deduplicate as Ee,defineProperty as Ae,filterKeys as Te,isNullable as ve,makeArray as E,mapValues as fe,noop as xe,omit as B,pick as Ne,remove as ce}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Context as Se,Service as Ie}from"https://registry.koishi.chat/modules/cordis/index.js";import{Binary as Me,isNullable as Pe}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{defineProperty as ee,isNullable as L,mapValues as te}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Binary as Fe,defineProperty as Y,isNullable as Z,mapValues as le}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{clone as Re,deepEqual as qe,defineProperty as Be,filterKeys as _e,isNullable as V,makeArray as S,mapValues as Ke}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{defineProperty as J,filterKeys as De,mapValues as me}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{deepEqual as Ue,defineProperty as Ve,mapValues as he,remove as ze}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Context as Ce,Service as Je}from"https://registry.koishi.chat/modules/cordis/index.js";import{isNullable as se}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Logger as ht,Schema as yt,Schema as dt}from"https://registry.koishi.chat/modules/cordis/index.js";var we=Object.defineProperty,g=(t,e)=>we(t,"name",{value:e,configurable:!0}),m;(t=>{t.kType=Symbol.for("minato.type"),t.Any=r("expr"),t.Boolean=r("boolean"),t.Number=r("double"),t.String=r("string"),t.Object=g(a=>Y({type:"json",inner:globalThis.Object.keys(a??{}).length?le(a,l=>f(l)?l:r(l)):void 0},t.kType,!0),"Object"),t.Array=g(a=>Y({type:"json",inner:a,array:!0},t.kType,!0),"Array");function e(a){if(Z(a))return r("expr");if(typeof a=="number")return t.Number;if(typeof a=="string")return t.String;if(typeof a=="boolean")return t.Boolean;if(typeof a=="bigint")return r("bigint");if(a instanceof Date)return r("timestamp");if(Fe.is(a))return r("binary");if(globalThis.Array.isArray(a))return(0,t.Array)(a.length?e(a[0]):void 0);if(typeof a=="object")return r("json");throw new TypeError(`invalid primitive: ${a}`)}t.fromPrimitive=e,g(e,"fromPrimitive");function r(a){if(f(a))return a;if(typeof a=="string")return Y({type:a},t.kType,!0);if(a.type)return a.type;if(a.expr?.[t.kType])return a.expr[t.kType];throw new TypeError(`invalid field: ${a}`)}t.fromField=r,g(r,"fromField");function i(a,l){return R(a)?a[t.kType]??l??r("expr"):e(a)}t.fromTerm=i,g(i,"fromTerm");function s(a,l){return a.map(u=>i(u)).find(u=>u.type!=="expr")??l??r("expr")}t.fromTerms=s,g(s,"fromTerms");function f(a){return a?.[t.kType]===!0}t.isType=f,g(f,"isType");function c(a){return a?.type==="json"&&a?.array}t.isArray=c,g(c,"isArray");function n(a,l){if(!a?.inner)return;if(c(a))return a.inner;if(Z(l))return;if(a.inner[l])return a.inner[l];if(l.includes("."))return l.split(".").reduce((y,b)=>n(y,b),a);let u=globalThis.Object.entries(a.inner).filter(([y])=>y.startsWith(`${l}.`)).map(([y,b])=>[y.slice(l.length+1),b]);return u.length?(0,t.Object)(globalThis.Object.fromEntries(u)):void 0}t.getInner=n,g(n,"getInner");function o(a,l,u){return!Z(a)&&l?.inner?t.isArray(l)?a.map(y=>u(y,t.getInner(l))).filter(y=>!l.ignoreNull||!Q(y)):l.ignoreNull&&Q(a)?null:le(a,(y,b)=>u(y,t.getInner(l,b))):a}t.transform=o,g(o,"transform")})(m||(m={}));var it=Symbol("minato.primary"),A;(t=>{let e=Symbol("minato.relation");t.Type=["oneToOne","oneToMany","manyToOne","manyToMany"];function r(...c){return"_"+c.sort().join("_")}t.buildAssociationTable=r,g(r,"buildAssociationTable");function i(c,n){return`${n}.${c}`}t.buildAssociationKey=i,g(i,"buildAssociationKey");function s(c,n){return[c,n].sort().join("_")}t.buildSharedKey=s,g(s,"buildSharedKey");function f(c,n,o,a,l){let u=c.shared?typeof c.shared=="string"?{[c.shared]:c.shared}:Array.isArray(c.shared)?Object.fromEntries(c.shared.map(h=>[h,h])):c.shared:{},y=c.fields??(l||c.type==="manyToOne"||c.type==="oneToOne"&&(o.name===a.name||!S(a.primary).every(h=>!a.fields[h]?.nullable))?S(a.primary).map(h=>`${n}.${h}`):o.primary),b={type:c.type,table:c.table??a.name,fields:S(y),shared:u,references:S(c.references??a.primary),required:c.type!=="manyToOne"&&o.name!==a.name&&S(y).every(h=>!o.fields[h]?.nullable||S(o.primary).includes(h))};Object.entries(u).forEach(([h,j])=>{b.fields=b.fields.filter(T=>T!==h),b.references=b.references.filter(T=>T!==j)});let d={type:b.type==="oneToMany"?"manyToOne":b.type==="manyToOne"?"oneToMany":b.type,table:o.name,fields:b.references,references:b.fields,shared:Object.fromEntries(Object.entries(u).map(([h,j])=>[j,h])),required:b.type!=="oneToMany"&&b.references.every(h=>!a.fields[h]?.nullable||S(a.primary).includes(h))};return d.required&&(b.required=!1),[b,d]}t.parse=f,g(f,"parse")})(A||(A={}));var w;(t=>{t.number=["integer","unsigned","float","double","decimal"],t.string=["char","string","text"],t.boolean=["boolean"],t.date=["timestamp","date","time"],t.object=["list","json"];let e=Symbol("minato.newtype"),r=/^(\w+)(?:\((.+)\))?$/;function i(c){if(typeof c=="function")throw new TypeError("view field is not supported");if(typeof c!="string")return{initial:null,deftype:c.type,...c,type:m.fromField(c.type)};let n=r.exec(c);if(!n)throw new TypeError("invalid field definition");let o=n[1],a=(n[2]||"").split(","),l={deftype:o,type:m.fromField(o)};return l.initial===void 0&&(l.initial=s(o)),o==="decimal"?(l.precision=+a[0],l.scale=+a[1]):a[0]&&(l.length=+a[0]),l}t.parse=i,g(i,"parse");function s(c,n){if(n===void 0){if(t.number.includes(c))return 0;if(t.string.includes(c))return"";if(c==="list")return[];if(c==="json")return{}}return n}t.getInitial=s,g(s,"getInitial");function f(c){return!!c&&!c.deprecated&&!c.relation&&c.deftype!=="expr"}t.available=f,g(f,"available")})(w||(w={}));var re=class{constructor(t){this.name=t,this.autoInc=!1,this.primary="id",this.unique=[],this.indexes=[],this.foreign={}}static{g(this,"Model")}fields={};migrations=new Map;extend(t={},e={}){let{primary:r,autoInc:i,unique:s=[],indexes:f=[],foreign:c,callback:n}=e;this.primary=r||this.primary,this.autoInc=i||this.autoInc,s.forEach(o=>this.unique.includes(o)||this.unique.push(o)),f.map(o=>this.parseIndex(o)).forEach(o=>this.indexes.some(a=>qe(a,o))||this.indexes.push(o)),Object.assign(this.foreign,c),n&&this.migrations.set(n,Object.keys(t));for(let o in t)this.fields[o]=w.parse(t[o]),this.fields[o].deprecated=!!n;typeof this.primary=="string"&&this.fields[this.primary]?.deftype==="primary"&&(this.autoInc=!0),this.checkIndex(this.primary),this.unique.forEach(o=>this.checkIndex(o)),this.indexes.forEach(o=>this.checkIndex(o))}parseIndex(t){return typeof t=="string"||Array.isArray(t)?{name:`index:${this.name}:`+S(t).join("+"),unique:!1,keys:Object.fromEntries(S(t).map(e=>[e,"asc"]))}:{name:t.name??`index:${this.name}:`+Object.keys(t.keys).join("+"),unique:t.unique??!1,keys:t.keys}}checkIndex(t){for(let e of typeof t=="string"||Array.isArray(t)?S(t):Object.keys(t.keys))if(!this.fields[e])throw new TypeError(`missing field definition for index key "${e}"`)}resolveValue(t,e){if(V(e))return e;if(typeof t=="string"&&(t=this.fields[t]),t&&(t=m.fromField(t)),t?.type==="time"){let r=new Date(0);return r.setHours(e.getHours(),e.getMinutes(),e.getSeconds(),e.getMilliseconds()),r}else if(t?.type==="date"){let r=new Date(e);return r.setHours(0,0,0,0),r}return e}resolveModel(t,e){if(e||(e=this.getType()),V(t)||!e.inner)return t;if(m.isArray(e)&&Array.isArray(t))return t.map(i=>this.resolveModel(i,m.getInner(e)));let r={};for(let i in t){let s=m.getInner(e,i);!s||V(t[i])?r[i]=t[i]:s.type!=="json"?r[i]=this.resolveValue(s,t[i]):s.inner&&m.isArray(s)&&Array.isArray(t[i])?r[i]=t[i].map(f=>this.resolveModel(f,m.getInner(s))):s.inner?r[i]=this.resolveModel(t[i],s):r[i]=t[i]}return r}format(t,e=!0,r="",i={}){let s=Object.keys(this.fields).filter(f=>!this.fields[f].relation);return Object.entries(t).map(([f,c])=>{if(f=r+f,c===void 0)return;if(s.includes(f)){i[f]=c;return}if(s.find(o=>f.startsWith(o+".")))i[f]=c;else if(U(c)){if(e&&(typeof c!="object"||Object.keys(c).length))throw new TypeError(`unknown field "${f}" in model ${this.name}`)}else this.format(c,e,f+".",i)}),e&&r===""?this.resolveModel(i):i}parse(t,e=!0,r="",i={}){let s=Object.keys(this.fields).filter(f=>!this.fields[f].relation);e&&r===""&&Object.assign(i,oe(Object.fromEntries(s.filter(f=>f.includes(".")).map(f=>[f.slice(0,f.lastIndexOf(".")),{}]))));for(let f in t){let c=i,n=f.split(".").reverse();for(let o=n.length-1;o>0;o--){let a=n[o];c=c[a]??={}}if(f in t){let o=r+f,a=t[f];if(s.find(u=>o===u||o.startsWith(u+".")))c[n[0]]=a;else if(U(a)){if(e)throw new TypeError(`unknown field "${o}" in model ${this.name}`);c[n[0]]=a}else this.parse(a,e,o+".",c[n[0]]??={})}}return e&&r===""?this.resolveModel(i):i}create(t){let e={},r=S(this.primary);for(let i in this.fields){if(!w.available(this.fields[i]))continue;let{initial:s}=this.fields[i];!r.includes(i)&&!V(s)&&(e[i]=Re(s))}return this.parse({...e,...t})}avaiableFields(){return _e(this.fields,(t,e)=>w.available(e))}getType(t){return this.type||Be(this,"type",m.Object(Ke(this.fields,e=>m.fromField(e)))),t?m.getInner(this.type,t):this.type}};function R(t){return t&&Object.keys(t).some(e=>e.startsWith("$"))}g(R,"isEvalExpr");var z=R;function de(t){return t.$||t.$select}g(de,"isAggrExpr");function C(t){return R(t)?Object.entries(t).filter(([e])=>e.startsWith("$")).some(([e,r])=>L(r)||X(r)?!1:e==="$exec"?!0:R(r)?C(r):Array.isArray(r)?r.some(i=>C(i)):typeof r=="object"?Object.values(r).some(i=>C(i)):!1):!1}g(C,"hasSubquery");var ke=Symbol("expr"),nt=Symbol("type"),ot=Symbol("aggr"),p=g((t,e,r)=>ee(ee({["$"+t]:e},ke,!0),m.kType,r),"Eval"),I=Object.create(null);I.$=G;function x(t,e,r){return I[`$${t}`]=e,i=>p(t,i,typeof r=="function"?r(i):r)}g(x,"unary");function v(t,e,r){return I[`$${t}`]=e,(...i)=>p(t,i,typeof r=="function"?r(...i):r)}g(v,"multary");function q(t,e){return I[`$${t}`]=(r,i)=>{let s=O(i,r[0]),f=O(i,r[1]);return L(s)||L(f)?!0:e(s.valueOf(),f.valueOf())},(...r)=>p(t,r,m.Boolean)}g(q,"comparator");p.switch=(t,e)=>p("switch",{branches:t,default:e},m.fromTerm(t[0]));I.$switch=(t,e)=>{for(let r of t.branches)if(O(e,r.case))return O(e,r.then);return O(e,t.default)};p.ignoreNull=t=>(t.$ignoreNull=!0,t[m.kType].ignoreNull=!0,t);p.select=v("select",(t,e)=>t.map(r=>O(e,r)),m.Array());p.query=(t,e,r=!0)=>({$expr:r,...e});p.exec=x("exec",(t,e)=>t.driver.executeSelection(t,e),t=>m.fromTerm(t.args[0]));p.if=v("if",([t,e,r],i)=>O(i,t)?O(i,e):O(i,r),(t,e,r)=>m.fromTerm(e));p.ifNull=v("ifNull",([t,e],r)=>O(r,t)??O(r,e),t=>m.fromTerm(t));p.add=v("add",(t,e)=>t.reduce((r,i)=>r+O(e,i),0),m.Number);p.mul=p.multiply=v("multiply",(t,e)=>t.reduce((r,i)=>r*O(e,i),1),m.Number);p.sub=p.subtract=v("subtract",([t,e],r)=>O(r,t)-O(r,e),m.Number);p.div=p.divide=v("divide",([t,e],r)=>O(r,t)/O(r,e),m.Number);p.mod=p.modulo=v("modulo",([t,e],r)=>O(r,t)%O(r,e),m.Number);p.abs=x("abs",(t,e)=>Math.abs(O(e,t)),m.Number);p.floor=x("floor",(t,e)=>Math.floor(O(e,t)),m.Number);p.ceil=x("ceil",(t,e)=>Math.ceil(O(e,t)),m.Number);p.round=x("round",(t,e)=>Math.round(O(e,t)),m.Number);p.exp=x("exp",(t,e)=>Math.exp(O(e,t)),m.Number);p.log=v("log",([t,e],r)=>Math.log(O(r,t))/Math.log(O(r,e??Math.E)),m.Number);p.pow=p.power=v("power",([t,e],r)=>Math.pow(O(r,t),O(r,e)),m.Number);p.random=()=>p("random",{},m.Number);I.$random=()=>Math.random();p.eq=q("eq",(t,e)=>t===e);p.ne=q("ne",(t,e)=>t!==e);p.gt=q("gt",(t,e)=>t>e);p.ge=p.gte=q("gte",(t,e)=>t>=e);p.lt=q("lt",(t,e)=>t<e);p.le=p.lte=q("lte",(t,e)=>t<=e);p.in=(t,e)=>p("in",[Array.isArray(t)?p.select(...t):t,e],m.Boolean);I.$in=([t,e],r)=>{let i=O(r,t),s=O(r,e);return typeof i=="object"?s.includes(i)||s.map(JSON.stringify).includes(JSON.stringify(i)):s.includes(i)};p.nin=(t,e)=>p("nin",[Array.isArray(t)?p.select(...t):t,e],m.Boolean);I.$nin=([t,e],r)=>{let i=O(r,t),s=O(r,e);return typeof i=="object"?!s.includes(i)&&!s.map(JSON.stringify).includes(JSON.stringify(i)):!s.includes(i)};p.concat=v("concat",(t,e)=>t.map(r=>O(e,r)).join(""),m.String);p.regex=v("regex",([t,e,r],i)=>W(O(i,e),r).test(O(i,t)),m.Boolean);p.and=v("and",(t,e)=>{let r=m.fromTerms(t,m.Boolean);if(w.boolean.includes(r.type))return t.every(i=>O(e,i));if(w.number.includes(r.type))return t.map(i=>O(e,i)).reduce((i,s)=>i&s);if(r.type==="bigint")return t.map(i=>BigInt(O(e,i)??0)).reduce((i,s)=>i&s)},(...t)=>m.fromTerms(t,m.Boolean));p.or=v("or",(t,e)=>{let r=m.fromTerms(t,m.Boolean);if(w.boolean.includes(r.type))return t.some(i=>O(e,i));if(w.number.includes(r.type))return t.map(i=>O(e,i)).reduce((i,s)=>i|s);if(r.type==="bigint")return t.map(i=>BigInt(O(e,i)??0)).reduce((i,s)=>i|s)},(...t)=>m.fromTerms(t,m.Boolean));p.not=x("not",(t,e)=>{let r=m.fromTerms([t],m.Boolean);if(w.boolean.includes(r.type))return!O(e,t);if(w.number.includes(r.type))return~O(e,t);if(r.type==="bigint")return~BigInt(O(e,t)??0)},t=>m.fromTerms([t],m.Boolean));p.xor=v("xor",(t,e)=>{let r=m.fromTerms(t,m.Boolean);if(w.boolean.includes(r.type))return t.map(i=>O(e,i)).reduce((i,s)=>i!==s);if(w.number.includes(r.type))return t.map(i=>O(e,i)).reduce((i,s)=>i^s);if(r.type==="bigint")return t.map(i=>BigInt(O(e,i)??0)).reduce((i,s)=>i^s)},(...t)=>m.fromTerms(t,m.Boolean));p.literal=v("literal",([t,e])=>{if(e)throw new TypeError("literal cast is not supported");return t},(t,e)=>e?m.fromField(e):m.fromTerm(t));p.number=x("number",(t,e)=>{let r=O(e,t);return r instanceof Date?Math.floor(r.valueOf()/1e3):Number(r)},m.Number);var be=g((t,e)=>{let r=m.fromTerm(t);return r=m.getInner(r)??r,e&&r.type==="expr"?e:r},"unwrapAggr");p.sum=x("sum",(t,e)=>Array.isArray(e)?e.reduce((r,i)=>r+P(t,i),0):Array.from(O(e,t)).reduce((r,i)=>r+i,0),m.Number);p.avg=x("avg",(t,e)=>{if(Array.isArray(e))return e.reduce((r,i)=>r+P(t,i),0)/e.length;{let r=Array.from(O(e,t));return r.reduce((i,s)=>i+s,0)/r.length}},m.Number);p.max=x("max",(t,e)=>Array.isArray(e)?e.map(r=>P(t,r)).reduce((r,i)=>r>i?r:i,-1/0):Array.from(O(e,t)).reduce((r,i)=>r>i?r:i,-1/0),t=>be(t,m.Number));p.min=x("min",(t,e)=>Array.isArray(e)?e.map(r=>P(t,r)).reduce((r,i)=>r<i?r:i,1/0):Array.from(O(e,t)).reduce((r,i)=>r<i?r:i,1/0),t=>be(t,m.Number));p.count=x("count",(t,e)=>new Set(e.map(r=>P(t,r))).size,m.Number);ee(p,"length",x("length",(t,e)=>Array.isArray(e)?e.map(r=>P(t,r)).length:Array.from(O(e,t)).length,m.Number));I.$object=(t,e)=>te(t,r=>P(r,e));p.object=t=>{if(t.$model){let e=Object.entries(t.$model.fields),r=t.$prefix;return t=Object.fromEntries(e.filter(([,i])=>w.available(i)).filter(([i])=>i.startsWith(r)).map(([i])=>[i.slice(r.length),t[i.slice(r.length)]])),p("object",t,m.Object(te(t,i=>m.fromTerm(i))))}return p("object",t,m.Object(te(t,e=>m.fromTerm(e))))};p.array=x("array",(t,e)=>Array.isArray(e)?e.map(r=>P(t,r)).filter(r=>!t[m.kType]?.ignoreNull||!Q(r)):Array.from(O(e,t)).filter(r=>!t[m.kType]?.ignoreNull||!Q(r)),t=>m.Array(m.fromTerm(t)));p.get=v("get",([t,e],r)=>O(r,t)?.[O(r,e)],(t,e)=>m.getInner(m.fromTerm(t),e)??m.Any);function G(t,e){if(typeof t=="string")return G(["_",t],e);let[r,i]=t,s=e[r];if(!s)return s;if(i in s)return s[i];let f=Object.keys(s).find(n=>i.startsWith(n+"."))||i.split(".",1)[0],c=i.slice(f.length+1).split(".").filter(Boolean);c.unshift(f);for(let n of c)if(s=s[n],!s)return s;return s}g(G,"getRecursive");function ie(t,e){for(let r in t)if(r in I)return I[r](t[r],e);return t}g(ie,"executeEvalExpr");function P(t,e){return typeof t=="string"?G(t,e):ie(t,e)}g(P,"executeAggr");function O(t,e){return X(e)||L(e)?e:Array.isArray(e)?e.map(r=>O(t,r)):ie(e,t)}g(O,"executeEval");function Qe(t,e,r){for(let i in e){let s=t,f=i.split("."),c=f.pop();for(let n of f)s=s[n]||={};s[c]=O({[r]:t,_:t},e[i])}return t}g(Qe,"executeUpdate");function X(t){return typeof t=="string"||typeof t=="number"||typeof t=="boolean"||typeof t=="bigint"||t instanceof Date}g(X,"isComparable");function U(t){return!t||typeof t!="object"||R(t)||Object.keys(t).length===0||Array.isArray(t)||t instanceof Date||t instanceof RegExp||Me.isSource(t)}g(U,"isFlat");var pe="abcdefghijklmnopqrstuvwxyz";function ne(){return Array(8).fill(0).map(()=>pe[Math.floor(Math.random()*pe.length)]).join("")}g(ne,"randomId");function W(t,e){return t instanceof RegExp&&!e?t:new RegExp(t.source??t,e??t.flags)}g(W,"makeRegExp");function oe(t,e){let r={};for(let i in t){let s=r,f=i.split(".").reverse();for(let c=f.length-1;c>0;c--){let n=f[c];s=s[n]??={},e&&(s=e(s))}s[f[0]]=t[i]}return r}g(oe,"unravel");function ae(t,e="",r=U){let i={};for(let s in t){let f=t[s];r(f)?i[`${e}${s}`]=f:Object.assign(i,ae(f,`${e}${s}.`,r))}return i}g(ae,"flatten");function $(t,e){if(e in t)return t[e];if(e.includes(".")){let r=e.indexOf(".");return $(t[e.slice(0,r)]??{},e.slice(r+1))}else return t[e]}g($,"getCell");function Q(t){if(Pe(t))return!0;if(typeof t!="object")return!1;for(let e in t)if(!Q(t[e]))return!1;return!0}g(Q,"isEmpty");var _=g((t,e={},r="",i,s)=>new Proxy(e,{get(f,c){if(c==="$prefix")return r;if(c==="$model")return i;if(typeof c=="symbol"||c in f||c.startsWith("$"))return Reflect.get(f,c);if(s)return m.isArray(e?.[m.kType])&&Number.isInteger(+c)?_(t,p.get(e,+c),"",i,p.get(e,+c)):_(t,p.get(s,`${r}${c}`),`${r}${c}.`,i,s);let n,o=i?.fields[r+c];if(m.isArray(e?.[m.kType])&&Number.isInteger(+c))return n=m.getInner(e?.[m.kType])??m.fromField("expr"),_(t,p.get(e,+c),"",i,p.get(e,+c));m.getInner(e?.[m.kType],c)?n=m.getInner(e?.[m.kType],c):o?n=m.fromField(o):Object.keys(i?.fields).some(l=>l.startsWith(`${r}${c}.`))?n=m.Object(Object.fromEntries(Object.entries(i?.fields).filter(([l])=>l.startsWith(`${r}${c}`)).map(([l,u])=>[l.slice(r.length+c.length+1),m.fromField(u)]))):n=i?.getType(`${r}${c}`)??m.fromField("expr");let a=_(t,p("",[t,`${r}${c}`],n),`${r}${c}.`,i);return!o&&Object.keys(i?.fields).some(l=>l.startsWith(`${r}${c}.`))?_(t,p.object(a),`${r}${c}.`,i):a}}),"createRow"),ue=class{static{g(this,"Executable")}row;model;driver;constructor(t,e){Object.assign(this,e),J(this,"driver",t),J(this,"model",t.model(this.table)),J(this,"row",_(this.ref,{},"",this.model))}resolveQuery(t={}){if(typeof t=="function"){let e=t(this.row);return e.$expr?e:R(e)?{$expr:e}:e}if(Array.isArray(t)||t instanceof RegExp||["string","number","bigint"].includes(typeof t)){let{primary:e}=this.model;if(Array.isArray(e))throw new TypeError("invalid shorthand for composite primary key");return{[e]:t}}return t}resolveField(t){if(typeof t=="string")return this.row[t];if(typeof t=="function")return t(this.row);throw new TypeError("invalid field definition")}resolveFields(t){if(typeof t=="string"&&(t=[t]),Array.isArray(t)){let e=Object.keys(this.model.fields),r=t.flatMap(i=>this.model.fields[i]?[[i,this.row[i]]]:e.some(s=>s.startsWith(i+"."))?e.filter(s=>s.startsWith(i+".")).map(s=>[s,this.row[s]]):[[i,i.split(".").reduce((s,f)=>s[f],this.row)]]);return Object.fromEntries(r)}else{let e=Object.entries(t).flatMap(([r,i])=>{let s=this.resolveField(i);return s.$object&&!m.fromTerm(s).ignoreNull?Object.entries(s.$object).map(([f,c])=>[`${r}.${f}`,c]):[[r,s]]});return Object.fromEntries(e)}}async execute(){return await this.driver.database.prepared(),await this.driver._ensureSession(),this.driver[this.type](this,...this.args)}},F=class D extends ue{static{g(this,"Selection")}tables={};constructor(e,r,i){super(e,{type:"get",ref:ne(),table:r,query:null,args:[{sort:[],limit:1/0,offset:0,group:void 0,having:p.and(),optional:{}}]}),this.tables[this.ref]=this.model,this.query=this.resolveQuery(i),typeof r!="string"&&Object.assign(this.tables,r.tables)}where(e){return this.query.$and||=[],this.query.$and.push(this.resolveQuery(e)),this}limit(...e){return e.length>1&&this.offset(e.shift()),this.args[0].limit=e[0],this}offset(e){return this.args[0].offset=e,this}orderBy(e,r="asc"){return this.args[0].sort.push([this.resolveField(e),r]),this}groupBy(e,...r){this.args[0].fields=this.resolveFields(e),this.args[0].group=Object.keys(this.args[0].fields);let i=typeof r[0]=="function"?void 0:r.shift();return Object.assign(this.args[0].fields,this.resolveFields(i||{})),r[0]&&this.having(r[0]),new D(this.driver,this)}having(e){return this.args[0].having.$and.push(this.resolveField(e)),this}project(e){return this.args[0].fields=this.resolveFields(e),new D(this.driver,this)}join(e,r,i=()=>p.and(),s=!1){let f=Object.fromEntries(Object.entries(this.model.fields).filter(([n,o])=>w.available(o)&&!n.startsWith(e+".")).map(([n])=>[n,o=>$(o[this.ref],n)])),c=Object.fromEntries(Object.entries(r.model.fields).filter(([n,o])=>w.available(o)||w.available(this.model.fields[`${e}.${n}`])).map(([n])=>[n,o=>w.available(this.model.fields[`${e}.${n}`])?$(o[this.ref],`${e}.${n}`):$(o[e],n)]));return s?this.driver.database.join({[this.ref]:this,[e]:r},n=>i(n[this.ref],n[e]),{[this.ref]:!1,[e]:!0}).project({...f,[e]:n=>p.ignoreNull(p.object(me(c,o=>o(n))))}):this.driver.database.join({[this.ref]:this,[e]:r},n=>i(n[this.ref],n[e])).project({...f,[e]:n=>p.ignoreNull(p.object(me(c,o=>o(n))))})}_action(e,...r){return new ue(this.driver,{...this,type:e,args:r})}evaluate(e){let r=new D(this.driver,this);e||(e=g(s=>p.array(p.object(s)),"callback"));let i=Array.isArray(e)?p.select(...e.map(s=>this.resolveField(s))):this.resolveField(e);return de(i)&&J(i,m.kType,m.Array(m.fromTerm(i))),p.exec(r._action("eval",i))}async execute(e){if(typeof e=="function")return new D(this.driver,this)._action("eval",this.resolveField(e)).execute();if(Array.isArray(e)?e={fields:e}:e||(e={}),e.fields&&this.project(e.fields),e.limit!==void 0&&this.limit(e.limit),e.offset!==void 0&&this.offset(e.offset),e.sort)for(let i in e.sort)this.orderBy(i,e.sort[i]);let r=await super.execute();return e.fields?r.map(i=>De(i,s=>e.fields.some(f=>f===s||f.startsWith(`${s}.`)))):r}};(t=>{function e(r){return r&&!!r.tables}t.is=e,g(e,"is")})(F||(F={}));function We(t,e,r){let{limit:i,offset:s,sort:f}=e;return t.sort((c,n)=>{for(let[o,a]of f){let l=a==="asc"?1:-1,u=O({[r]:c,_:c},o),y=O({[r]:n,_:n},o);if(u<y)return-l;if(u>y)return l}return 0}),t.slice(s,s+i)}g(We,"executeSort");function K(t,e){return typeof e=="function"?r=>{let i=e(r);return{$expr:!0,...t,...i.$expr?i:{$expr:i}}}:r=>({$expr:!0,...t,...e})}g(K,"mergeQuery");var ge=class M extends Ie{static{g(this,"Database")}static transact=Symbol("minato.transact");static migrate=Symbol("minato.migrate");tables=Object.create(null);drivers=[];types=Object.create(null);_driver;stashed=new Set;prepareTasks=Object.create(null);migrateTasks=Object.create(null);constructor(e){e||=new Se,super(e,"model",!0)}async connect(e,...r){this.ctx.plugin(e,r[0]),await this.ctx.start()}refresh(){for(let e in this.tables)this.prepareTasks[e]=this.prepare(e)}async prepared(){this[M.migrate]||await Promise.all(Object.values(this.prepareTasks))}getDriver(e){if(F.is(e))return e.driver;let r=this.tables[e];if(!r)throw new Error(`cannot resolve table "${e}"`);return r.ctx?.get("database")?._driver}async prepare(e){if(this.stashed.add(e),await this.prepareTasks[e],await Promise.resolve(),!this.stashed.delete(e))return;let r=this.getDriver(e);if(!r)return;let{fields:i}=r.model(e);Object.values(i).forEach(s=>s?.transformers?.forEach(f=>r.define(f))),await r.prepare(e),await r.prepareIndexes(e)}extend(e,r,i={}){let s=this.tables[e];s||(s=this.tables[e]=new re(e)),Object.entries(r).forEach(([f,c])=>{let n=[];this.parseField(c,n,void 0,o=>c=r[f]=o),typeof c=="object"&&(c.transformers=n)}),s.extend(r,i),E(s.primary).every(f=>f in r)&&Ae(s,"ctx",this.ctx),Object.entries(r).forEach(([f,c])=>{if(!A.Type.includes(c.type))return;let n=!c.fields&&E(s.primary).includes(f),[o,a]=A.parse(c,f,s,this.tables[c.table??f],n),l=this.tables[o.table];if(!l)throw new Error(`relation table ${o.table} does not exist`);if((s.fields[f]=w.parse("expr")).relation=o,c.target&&((l.fields[c.target]??=w.parse("expr")).relation=a),o.type==="oneToOne"||o.type==="manyToOne")o.fields.forEach((u,y)=>{s.fields[u]??={...l.fields[o.references[y]]},o.required||(s.fields[u].nullable=!0,s.fields[u].initial=null)});else if(o.type==="manyToMany"){let u=A.buildAssociationTable(o.table,e);if(this.tables[u])return;let y=Object.entries(o.shared).map(([h,j])=>[A.buildSharedKey(h,j),s.fields[h].deftype]),b=o.fields.map(h=>[A.buildAssociationKey(h,e),s.fields[h].deftype]),d=o.references.map(h=>[A.buildAssociationKey(h,o.table),l.fields[h]?.deftype]);this.extend(u,{...Object.fromEntries([...y,...b,...d]),[e]:{type:"manyToOne",table:e,fields:[...y,...b].map(h=>h[0]),references:[...Object.keys(o.shared),...o.fields]},[o.table]:{type:"manyToOne",table:o.table,fields:[...y,...d].map(h=>h[0]),references:[...Object.values(o.shared),...o.references]}},{primary:[...y,...b,...d].map(h=>h[0])})}}),(Array.isArray(s.primary)||s.fields[s.primary].relation)&&(s.primary=Ee(E(s.primary).map(f=>s.fields[f].relation?.fields||f).flat())),s.unique=s.unique.map(f=>typeof f=="string"?s.fields[f].relation?.fields||f:f.map(c=>s.fields[c].relation?.fields||c).flat()),this.prepareTasks[e]=this.prepare(e),this.ctx.emit("model",e)}_parseField(e,r=[],i,s){if(e==="object")return i?.({}),s?.({initial:{},deftype:"json",type:m.Object()}),m.Object();if(e==="array")return i?.([]),s?.({initial:[],deftype:"json",type:m.Array()}),m.Array();if(typeof e=="string"&&this.types[e])return r.push({types:[e],load:this.types[e].load,dump:this.types[e].dump},...this.types[e].transformers??[]),i?.(this.types[e].initial),s?.({...this.types[e],type:e}),m.fromField(e);if(typeof e=="string")return i?.(w.getInitial(e.split("(")[0])),s?.(e),m.fromField(e.split("(")[0]);if(typeof e=="object"&&e.type==="object"){let f=e.inner?oe(e.inner,o=>(o.type="object",o.inner??={})):Object.create(null),c=Object.create(null),n=m.Object(fe(f,(o,a)=>this.parseField(o,r,l=>c[a]=l)));return i?.(w.getInitial("json",c)),s?.({initial:w.getInitial("json",c),...e,deftype:"json",type:n}),n}else if(typeof e=="object"&&e.type==="array"){let f=e.inner?m.Array(this.parseField(e.inner,r)):m.Array();return i?.([]),s?.({initial:[],...e,deftype:"json",type:f}),f}else return typeof e=="object"&&this.types[e.type]?(r.push({types:[e.type],load:this.types[e.type].load,dump:this.types[e.type].dump},...this.types[e.type].transformers??[]),i?.(e.initial===void 0?this.types[e.type].initial:e.initial),s?.({initial:this.types[e.type].initial,...e}),m.fromField(e.type)):(i?.(w.getInitial(e.type,e.initial)),s?.(e),m.fromField(e.type))}parseField(e,r=[],i,s){let f,c=this._parseField(e,r,i,n=>(f=n,s?.(n)));if(typeof e=="object"&&e.load&&e.dump){c.inner&&(c=m.fromField(this.define({...B(f,["load","dump"]),type:c})));let n=this.define({...e,deftype:f.deftype,type:c.type});return r.push({types:[n],load:e.load,dump:e.dump}),i?.(e.initial),s?.({...e,deftype:f.deftype??this.types[c.type]?.deftype??c.type,initial:f.initial,type:n}),m.fromField(n)}return typeof f=="object"&&s?.({...f,deftype:f.deftype??this.types[c.type]?.deftype??c?.type}),c}define(e,r){if(typeof e=="object"&&(r=e,e=void 0),e&&this.types[e])throw new Error(`type "${e}" already defined`);if(!e)for(;this.types[e="_define_"+ne()];);let i=[],s=this._parseField(r,i,void 0,f=>r=f);return r.transformers=i,this.ctx.effect(()=>(this.types[e]={...r},this.types[e].deftype??=this.types[r.type]?.deftype??s.type,()=>delete this.types[e])),e}migrate(e,r,i){this.extend(e,r,{callback:i})}select(e,r,i){let s=new F(this.getDriver(e),e,r);if(typeof e!="string")return s;let f=i===null,c=typeof r=="function"?r:()=>r,n=this.tables[e].fields;i&&(i=Te(i,o=>!!n[o]?.relation));for(let o in{...s.query,...s.query.$not})n[o]?.relation&&(s.query[o]===null&&!n[o].relation.required&&(s.query[o]=Object.fromEntries(n[o].relation.references.map(a=>[a,null]))),s.query[o]&&typeof s.query[o]!="function"&&typeof s.query[o]=="object"&&Object.keys(s.query[o]).every(a=>n[o].relation.fields.includes(`${o}.${a}`))&&(Object.entries(s.query[o]).forEach(([a,l])=>s.query[`${o}.${a}`]=l),delete s.query[o]),s.query.$not?.[o]===null&&!n[o].relation.required&&(s.query.$not[o]=Object.fromEntries(n[o].relation.references.map(a=>[a,null]))),s.query.$not?.[o]&&typeof s.query.$not[o]!="function"&&typeof s.query.$not[o]=="object"&&Object.keys(s.query.$not[o]).every(a=>n[o].relation.fields.includes(`${o}.${a}`))&&(Object.entries(s.query.$not[o]).forEach(([a,l])=>s.query.$not[`${o}.${a}`]=l),delete s.query.$not[o]),(!i||!Object.getOwnPropertyNames(i).includes(o))&&((i??={})[o]=!0));if(s.query=B(s.query,Object.keys(i??{})),Object.keys(s.query.$not??{}).length&&(s.query.$not=B(s.query.$not,Object.keys(i??{})),Object.keys(s.query.$not).length===0&&Reflect.deleteProperty(s.query,"$not")),i&&typeof i=="object"){if(typeof e!="string")throw new Error("cannot include relations on derived selection");let o=[],a=g((l,u)=>{let y=c(l.row),b=y[u]!==void 0?y[u]:y.$not?.[u]!==void 0?{$not:y.$not?.[u]}:void 0;return b===void 0?l:l.where(this.transformRelationQuery(e,l.row,u,b))},"applyQuery");for(let l in i){if(!i[l]||!n[l]?.relation)continue;let u=n[l].relation;if(u.type==="oneToOne"||u.type==="manyToOne")s=f?s:s.join(l,this.select(u.table,{},i[l]),(y,b)=>p.and(...u.fields.map((d,h)=>p.eq(y[d],b[u.references[h]]))),!0),s=a(s,l);else if(u.type==="oneToMany")s=f?s:s.join(l,this.select(u.table,{},i[l]),(y,b)=>p.and(...u.fields.map((d,h)=>p.eq(y[d],b[u.references[h]]))),!0),s=a(s,l),s=f?s:s.groupBy([...Object.entries(n).filter(([y,b])=>!o.some(d=>y.startsWith(`${d}.`))&&w.available(b)).map(([y])=>y),...o],{[l]:y=>p.ignoreNull(p.array(y[l]))});else if(u.type==="manyToMany"){let y=A.buildAssociationTable(u.table,e),b=u.fields.map(h=>A.buildAssociationKey(h,e)),d=Object.entries(u.shared).map(([h,j])=>[A.buildSharedKey(h,j),{field:h,reference:j}]);s=f?s:s.join(l,this.select(y,{},{[u.table]:i[l]}),(h,j)=>p.and(...d.map(([T,N])=>p.eq(h[N.field],j[T])),...u.fields.map((T,N)=>p.eq(h[T],j[b[N]]))),!0),s=a(s,l),s=f?s:s.groupBy([...Object.entries(n).filter(([h,j])=>!o.some(T=>h.startsWith(`${T}.`))&&w.available(j)).map(([h])=>h),...o],{[l]:h=>p.ignoreNull(p.array(h[l][u.table]))})}o.push(l)}}return s}join(e,r=(...s)=>p.and(),i){let s=e;Array.isArray(s)&&(e=Object.fromEntries(s.map(o=>[o,this.select(o)])));let f=fe(e,o=>typeof o=="string"?this.select(o):o);if(Object.keys(f).length===0)throw new Error("no tables to join");let c=new Set(Object.values(f).map(o=>o.driver[M.transact]??o.driver));if(c.size!==1)throw new Error("cannot join tables from different drivers");if(Object.keys(f).length===2&&(i?.[0]||i?.[Object.keys(f)[0]])){if(i[1]||i[Object.keys(f)[1]])throw new Error("full join is not supported");f=Object.fromEntries(Object.entries(f).reverse())}let n=new F([...c][0],f);return Array.isArray(s)?(n.args[0].having=p.and(r(...s.map(o=>n.row[o]))),n.args[0].optional=Object.fromEntries(s.map((o,a)=>[o,i?.[a]]))):(n.args[0].having=p.and(r(n.row)),n.args[0].optional=i),this.select(n)}async get(e,r,i){let s=Array.isArray(i)?i:i?.fields;return s=s?Object.fromEntries(s.map(f=>[f,!0])):i?.include,this.select(e,r,s).execute(i)}async eval(e,r,i){return this.select(e,i).execute(typeof r=="function"?r:()=>r)}async set(e,r,i){let s=typeof i=="function"?i:()=>i,f=this.select(e,r,null);if(typeof i=="function"&&(i=i(f.row)),E(f.model.primary).some(o=>o in i))throw new TypeError("cannot modify primary key");let n=Object.entries(f.model.fields).filter(([o,a])=>o in i&&a.relation).map(([o,a])=>[o,a.relation]);return n.length?await this.ensureTransaction(async o=>{let a=await o.get(e,r);f=o.select(e,r,null);let l=B(s(f.row),n.map(([u])=>u));l=f.model.format(l);for(let[u]of n)await Promise.all(a.map(y=>o.processRelationUpdate(e,y,u,s(y)[u])));return Object.keys(l).length===0?{}:await f._action("set",l).execute()}):(i=f.model.format(i),Object.keys(i).length===0?{}:f._action("set",i).execute())}async remove(e,r){return this.select(e,r,null)._action("remove").execute()}async create(e,r){let i=this.select(e);if(this.hasRelation(e,r))return this.ensureTransaction(s=>s.createOrUpdate(e,r,!1));{let{primary:s,autoInc:f}=i.model;if(!f&&E(s).some(n=>$(r,n)===void 0))throw new Error("missing primary key");return i._action("create",i.model.create(r)).execute()}}async upsert(e,r,i){let s=this.select(e);return typeof r=="function"&&(r=r(s.row)),r=r.map(f=>s.model.format(f)),i=E(i||s.model.primary),s._action("upsert",r,i).execute()}makeProxy(e,r){let i=new Map,s=new Proxy(this,{get:g((f,c,n)=>c===e?!0:c!=="getDriver"?Reflect.get(f,c,n):o=>{let a=this.getDriver(o),l=i.get(a);return l||(l=r?.(a,s)??new Proxy(a,{get:g((u,y,b)=>y==="database"?s:Reflect.get(u,y,b),"get")}),i.set(a,l)),l},"get")});return s}withTransaction(e){return this.transact(e)}async transact(e){if(this[M.transact])throw new Error("nested transactions are not supported");let r=[],i=this.makeProxy(M.transact,c=>{let n=!1,o,a,l=new Promise(u=>a=u);return c=new Proxy(c,{get:g((u,y,b)=>y===M.transact?u:y==="database"?i:y==="session"?o:y==="_ensureSession"?()=>l:Reflect.get(u,y,b),"get")}),r.push(c.withTransaction(u=>(n&&(f=s()),n=!0,a(o=u),f))),c}),s=g(()=>Promise.resolve().then(()=>e(i)),"initialTaskFactory"),f=s();return f.catch(xe).finally(()=>Promise.all(r))}async stopAll(){await Promise.all(this.drivers.splice(0,1/0).map(e=>e.stop()))}async drop(e){if(this[M.transact])throw new Error("cannot drop table in transaction");await this.getDriver(e).drop(e)}async dropAll(){if(this[M.transact])throw new Error("cannot drop table in transaction");await Promise.all(Object.values(this.drivers).map(e=>e.dropAll()))}async stats(){await this.prepared();let e={size:0,tables:{}};return await Promise.all(Object.values(this.drivers).map(async r=>{let{size:i=0,tables:s}=await r.stats();e.size+=i,Object.assign(e.tables,s)})),e}ensureTransaction(e){return this[M.transact]?e(this):this.transact(e)}transformRelationQuery(e,r,i,s){let f=this.tables[e].fields[i].relation,c=[];if(f.type==="oneToOne"||f.type==="manyToOne")s===null?c.push(p.nin(f.fields.map(n=>r[n]),this.select(f.table).evaluate(f.references))):c.push(p.in(f.fields.map(n=>r[n]),this.select(f.table,s).evaluate(f.references)));else if(f.type==="oneToMany")s.$or&&c.push(p.or(...s.$or.map(n=>this.transformRelationQuery(e,r,i,n).$expr))),s.$and&&c.push(...s.$and.map(n=>this.transformRelationQuery(e,r,i,n).$expr)),s.$not&&c.push(p.not(this.transformRelationQuery(e,r,i,s.$not).$expr)),s.$some&&c.push(p.in(f.fields.map(n=>r[n]),this.select(f.table,s.$some).evaluate(f.references))),s.$none&&c.push(p.nin(f.fields.map(n=>r[n]),this.select(f.table,s.$none).evaluate(f.references))),s.$every&&c.push(p.nin(f.fields.map(n=>r[n]),this.select(f.table,p.not(s.$every)).evaluate(f.references)));else if(f.type==="manyToMany"){let n=A.buildAssociationTable(e,f.table),o=f.fields.map(l=>A.buildAssociationKey(l,e)),a=f.references.map(l=>A.buildAssociationKey(l,f.table));if(s.$or&&c.push(p.or(...s.$or.map(l=>this.transformRelationQuery(e,r,i,l).$expr))),s.$and&&c.push(...s.$and.map(l=>this.transformRelationQuery(e,r,i,l).$expr)),s.$not&&c.push(p.not(this.transformRelationQuery(e,r,i,s.$not).$expr)),s.$some){let l=this.select(f.table,s.$some).evaluate(f.references),u=this.select(n,y=>p.in(a.map(b=>y[b]),l)).evaluate(o);c.push(p.in(f.fields.map(y=>r[y]),u))}if(s.$none){let l=this.select(f.table,s.$none).evaluate(f.references),u=this.select(n,y=>p.in(a.map(b=>y[b]),l)).evaluate(o);c.push(p.nin(f.fields.map(y=>r[y]),u))}if(s.$every){let l=this.select(f.table,p.not(s.$every)).evaluate(f.references),u=this.select(n,y=>p.in(a.map(b=>y[b]),l)).evaluate(o);c.push(p.nin(f.fields.map(y=>r[y]),u))}}return{$expr:p.and(...c)}}async createOrUpdate(e,r,i=!0){let s=this.select(e);r={...r};let f=[""];for(let c in r)if(r[c]!==void 0&&this.tables[e].fields[c]?.relation){let n=this.tables[e].fields[c].relation;n.type==="oneToOne"&&n.required?f.push(c):n.type==="oneToOne"?f.unshift(c):n.type==="oneToMany"?f.push(c):n.type==="manyToOne"?f.unshift(c):n.type==="manyToMany"&&f.push(c)}for(let c of[...f]){if(!c){let{primary:a,autoInc:l}=s.model,u=E(a);if(u.some(y=>ve($(r,y))))if(l)delete r[a],i=!1;else throw new Error("missing primary key");i?await s._action("upsert",[s.model.format(B(r,f))],u).execute():Object.assign(r,await s._action("create",s.model.create(B(r,f))).execute());continue}let n=r[c],o=this.tables[e].fields[c].relation;if(o.type==="oneToOne"){if(n.$literal)r[c]=n.$literal,ce(f,c);else if(n.$create||!z(n)){let a=await this.createOrUpdate(o.table,{...Object.fromEntries(o.references.map((l,u)=>[l,$(r,o.fields[u])])),...n.$create??n});o.required||o.references.forEach((l,u)=>r[o.fields[u]]=$(a,l))}else if(n.$upsert)await this.upsert(o.table,[{...Object.fromEntries(o.references.map((a,l)=>[a,$(r,o.fields[l])])),...n.$upsert}]),o.required||o.references.forEach((a,l)=>r[o.fields[l]]=$(n.$upsert,a));else if(n.$connect)if(o.required)await this.set(o.table,n.$connect,Object.fromEntries(o.references.map((a,l)=>[a,$(r,o.fields[l])])));else{let a=o.references.every(l=>n.$connect[l]!==void 0)?[n.$connect]:await this.get(o.table,n.$connect);if(a.length!==1)throw new Error("related row not found or not unique");o.references.forEach((l,u)=>r[o.fields[u]]=$(a[0],l))}}else if(o.type==="manyToOne"){if(n.$literal)r[c]=n.$literal,ce(f,c);else if(n.$create||!z(n)){let a=await this.createOrUpdate(o.table,n.$create??n);o.references.forEach((l,u)=>r[o.fields[u]]=$(a,l))}else if(n.$upsert)await this.upsert(o.table,[n.$upsert]),o.references.forEach((a,l)=>r[o.fields[l]]=$(n.$upsert,a));else if(n.$connect){let a=o.references.every(l=>n.$connect[l]!==void 0)?[n.$connect]:await this.get(o.table,n.$connect);if(a.length!==1)throw new Error("related row not found or not unique");o.references.forEach((l,u)=>r[o.fields[u]]=$(a[0],l))}}else if(o.type==="oneToMany"){if(n.$create||Array.isArray(n))for(let a of E(n.$create??n))await this.createOrUpdate(o.table,{...Object.fromEntries(o.references.map((l,u)=>[l,$(r,o.fields[u])])),...a});n.$upsert&&await this.upsert(o.table,E(n.$upsert).map(a=>({...Object.fromEntries(o.references.map((l,u)=>[l,$(r,o.fields[u])])),...a}))),n.$connect&&await this.set(o.table,n.$connect,Object.fromEntries(o.references.map((a,l)=>[a,$(r,o.fields[l])])))}else if(o.type==="manyToMany"){let a=A.buildAssociationTable(o.table,e),l=o.fields.map(d=>A.buildAssociationKey(d,e)),u=o.references.map(d=>A.buildAssociationKey(d,o.table)),y=Object.entries(o.shared).map(([d,h])=>[A.buildSharedKey(d,h),{field:d,reference:h}]),b=[];if(n.$create||Array.isArray(n))for(let d of E(n.$create??n))b.push(await this.createOrUpdate(o.table,{...Object.fromEntries(y.map(([,h])=>[h.reference,$(d,h.reference)??$(r,h.field)])),...d}));if(n.$upsert){let d=E(n.$upsert).map(h=>({...Object.fromEntries(y.map(([,j])=>[j.reference,$(h,j.reference)??$(r,j.field)])),...h}));await this.upsert(o.table,d),b.push(...d)}if(n.$connect)for(let d of E(n.$connect))u.every(h=>d[h]!==void 0)?b.push(d):b.push(...await this.get(o.table,d));await this.upsert(a,b.map(d=>({...Object.fromEntries(y.map(([h,j])=>[h,$(d,j.reference)??$(r,j.field)])),...Object.fromEntries(l.map((h,j)=>[h,$(r,o.fields[j])])),...Object.fromEntries(u.map((h,j)=>[h,$(d,o.references[j])]))})))}}return r}async processRelationUpdate(e,r,i,s){let f=this.tables[e],c=Object.create(null),n=this.tables[e].fields[i].relation;if(n.type==="oneToOne"){if(s===null&&(s=n.required?{$remove:{}}:{$disconnect:{}}),typeof s=="object"&&!z(s)&&(s={$create:s}),s.$remove&&await this.remove(n.table,Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])]))),s.$disconnect&&(n.required?await this.set(n.table,K(Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])])),s.$disconnect),Object.fromEntries(n.references.map((o,a)=>[o,null]))):Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,null])))),(s.$set||typeof s=="function")&&await this.set(n.table,Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])])),s.$set??s),s.$create){let o=await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((a,l)=>[a,$(r,n.fields[l])])),...s.$create});n.required||Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,$(o,n.references[l])])))}if(s.$upsert&&(await this.upsert(n.table,E(s.$upsert).map(o=>({...Object.fromEntries(n.references.map((a,l)=>[a,$(r,n.fields[l])])),...o}))),n.required||Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,$(s.$upsert,n.references[a])])))),s.$connect)if(n.required)await this.set(n.table,s.$connect,Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])])));else{let o=await this.get(n.table,s.$connect);if(o.length!==1)throw new Error("related row not found or not unique");Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,$(o[0],n.references[l])])))}}else if(n.type==="manyToOne"){if(s===null&&(s={$disconnect:{}}),typeof s=="object"&&!z(s)&&(s={$create:s}),s.$remove&&await this.remove(n.table,Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])]))),s.$disconnect&&Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,null]))),(s.$set||typeof s=="function")&&await this.set(n.table,Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])])),s.$set??s),s.$create){let o=await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((a,l)=>[a,$(r,n.fields[l])])),...s.$create});Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,$(o,n.references[l])])))}if(s.$upsert&&(await this.upsert(n.table,E(s.$upsert).map(o=>({...Object.fromEntries(n.references.map((a,l)=>[a,$(r,n.fields[l])])),...o}))),Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,$(s.$upsert,n.references[a])])))),s.$connect){let o=await this.get(n.table,s.$connect);if(o.length!==1)throw new Error("related row not found or not unique");Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,$(o[0],n.references[l])])))}}else if(n.type==="oneToMany"){if(Array.isArray(s)){let o=[],a=[];s.forEach(l=>this.hasRelation(n.table,l)?o.push(l):a.push(l)),s={$remove:{},$create:o,$upsert:a}}if(s.$remove&&await this.remove(n.table,K(Object.fromEntries(n.references.map((o,a)=>[o,r[n.fields[a]]])),s.$remove)),s.$disconnect&&await this.set(n.table,K(Object.fromEntries(n.references.map((o,a)=>[o,$(r,n.fields[a])])),s.$disconnect),Object.fromEntries(n.references.map((o,a)=>[o,null]))),s.$set||typeof s=="function")for(let o of E(s.$set??s)){let[a,l]=o.update?[o.where,o.update]:[{},o];await this.set(n.table,K(Object.fromEntries(n.references.map((u,y)=>[u,r[n.fields[y]]])),a),l)}if(s.$create)for(let o of E(s.$create))await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((a,l)=>[a,$(r,n.fields[l])])),...o});s.$upsert&&await this.upsert(n.table,E(s.$upsert).map(o=>({...Object.fromEntries(n.references.map((a,l)=>[a,$(r,n.fields[l])])),...o}))),s.$connect&&await this.set(n.table,s.$connect,Object.fromEntries(n.references.map((o,a)=>[o,r[n.fields[a]]])))}else if(n.type==="manyToMany"){let o=A.buildAssociationTable(e,n.table),a=n.fields.map(y=>A.buildAssociationKey(y,e)),l=n.references.map(y=>A.buildAssociationKey(y,n.table)),u=Object.entries(n.shared).map(([y,b])=>[A.buildSharedKey(y,b),{field:y,reference:b}]);if(Array.isArray(s)){let y=[],b=[];s.forEach(d=>this.hasRelation(n.table,d)?y.push(d):b.push(d)),s={$disconnect:{},$create:y,$upsert:b}}if(s.$remove){let y=await this.select(o,{...Object.fromEntries(u.map(([b,d])=>[b,$(r,d.field)])),...Object.fromEntries(a.map((b,d)=>[b,$(r,n.fields[d])])),[n.table]:s.$remove},null).execute();await this.remove(o,b=>p.in([...u.map(([d,h])=>b[d]),...a.map(d=>b[d]),...l.map(d=>b[d])],y.map(d=>[...u.map(([h,j])=>$(d,h)),...a.map(h=>$(d,h)),...l.map(h=>$(d,h))]))),await this.remove(n.table,b=>p.in([...u.map(([d,h])=>b[h.reference]),...n.references.map(d=>b[d])],y.map(d=>[...u.map(([h,j])=>$(d,h)),...l.map(h=>$(d,h))])))}if(s.$disconnect){let y=await this.select(o,{...Object.fromEntries(u.map(([b,d])=>[b,$(r,d.field)])),...Object.fromEntries(a.map((b,d)=>[b,$(r,n.fields[d])])),[n.table]:s.$disconnect},null).execute();await this.remove(o,b=>p.in([...u.map(([d,h])=>b[d]),...a.map(d=>b[d]),...l.map(d=>b[d])],y.map(d=>[...u.map(([h,j])=>$(d,h)),...a.map(h=>$(d,h)),...l.map(h=>$(d,h))])))}if(s.$set)for(let y of E(s.$set)){let[b,d]=y.update?[y.where,y.update]:[{},y],h=await this.select(o,j=>({...Object.fromEntries(u.map(([T,N])=>[T,$(r,N.field)])),...Object.fromEntries(a.map((T,N)=>[T,$(r,n.fields[N])])),[n.table]:b}),null).execute();await this.set(n.table,j=>p.in([...u.map(([T,N])=>j[N.reference]),...n.references.map(T=>j[T])],h.map(T=>[...u.map(([N,He])=>$(T,N)),...l.map(N=>$(T,N))])),d)}if(s.$create){let y=[];for(let b of E(s.$create))y.push(await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((d,h)=>[d,$(r,n.fields[h])])),...b}));await this.upsert(o,y.map(b=>({...Object.fromEntries(u.map(([d,h])=>[d,$(r,h.field)])),...Object.fromEntries(a.map((d,h)=>[d,r[n.fields[h]]])),...Object.fromEntries(l.map((d,h)=>[d,b[n.references[h]]]))})))}if(s.$upsert&&(await this.upsert(n.table,E(s.$upsert).map(y=>({...Object.fromEntries(n.references.map((b,d)=>[b,$(r,n.fields[d])])),...y}))),await this.upsert(o,E(s.$upsert).map(y=>({...Object.fromEntries(u.map(([b,d])=>[b,$(r,d.field)])),...Object.fromEntries(a.map((b,d)=>[b,r[n.fields[d]]])),...Object.fromEntries(l.map((b,d)=>[b,y[n.references[d]]]))})))),s.$connect){let y=await this.get(n.table,K(Object.fromEntries(u.map(([b,d])=>[d.reference,$(r,d.field)])),s.$connect));await this.upsert(o,y.map(b=>({...Object.fromEntries(u.map(([d,h])=>[d,$(r,h.field)])),...Object.fromEntries(a.map((d,h)=>[d,r[n.fields[h]]])),...Object.fromEntries(l.map((d,h)=>[d,b[n.references[h]]]))})))}}Object.keys(c).length&&await this.set(e,Ne(f.format(r),E(f.primary)),c)}hasRelation(e,r){for(let i in r)if(r[i]!==void 0&&this.tables[e].fields[i]?.relation)return!0;return!1}},lt=class{constructor(t,e){this.ctx=t,this.config=e,this.database=t.model,this.logger=t.logger(this.constructor.name),t.on("ready",async()=>{await Promise.resolve(),await this.start(),t.model.drivers.push(this),t.model.refresh();let r=Object.create(t.model);Ve(r,"ctx",t),r._driver=this,r[Je.tracker]={associate:"database",property:"ctx"},t.set("database",Ce.associate(r,"database"))}),t.on("dispose",async()=>{ze(t.model.drivers,this),await this.stop()})}static{g(this,"Driver")}static inject=["model"];database;logger;types=Object.create(null);model(t){if(typeof t=="string"){let r=this.database.tables[t];if(r)return r;throw new TypeError(`unknown table name "${t}"`)}if(F.is(t)){if(!t.args[0].fields&&(typeof t.table=="string"||F.is(t.table)))return t.model;let r=new re("temp");return t.args[0].fields?r.fields=he(t.args[0].fields,i=>({type:m.fromTerm(i)})):r.fields=he(t.model.fields,i=>({type:m.fromField(i)})),r}let e=new re("temp");for(let r in t){let i=this.model(t[r]);for(let s in i.fields)w.available(i.fields[s])&&(e.fields[`${r}.${s}`]={expr:p("",[t[r].ref,s],m.fromField(i.fields[s])),type:m.fromField(i.fields[s])})}return e}async migrate(t,e){let r=this.database.makeProxy(ge.migrate),i=this.model(t);await(r.migrateTasks[t]=Promise.resolve(r.migrateTasks[t]).then(()=>Promise.all([...i.migrations].map(async([s,f])=>{try{if(!e.before(f))return;await s(r),e.after(f)}catch(c){e.error(c)}}))).then(e.finalize).catch(e.error))}define(t){t.types.forEach(e=>this.types[e]=t)}async _ensureSession(){}async prepareIndexes(t){let e=await this.getIndexes(t),{indexes:r}=this.model(t);for(let i of r){let s=e.find(f=>f.name===i.name);s?Ue(s,i)||(await this.dropIndex(t,i.name),await this.createIndex(t,i)):await this.createIndex(t,i)}}},pt=class $e extends Error{constructor(e,r){super(r||e.replace("-"," ")),this.code=e}static{g(this,"RuntimeError")}name="RuntimeError";static check(e,r){return e instanceof $e?!r||e.message===r:!1}},ye={$or:g((t,e)=>t.reduce((r,i)=>r||k(i,e),!1),"$or"),$and:g((t,e)=>t.reduce((r,i)=>r&&k(i,e),!0),"$and"),$not:g((t,e)=>!k(t,e),"$not"),$exists:g((t,e)=>t!==se(e),"$exists"),$eq:g((t,e)=>e.valueOf()===t.valueOf(),"$eq"),$ne:g((t,e)=>e.valueOf()!==t.valueOf(),"$ne"),$gt:g((t,e)=>e.valueOf()>t.valueOf(),"$gt"),$gte:g((t,e)=>e.valueOf()>=t.valueOf(),"$gte"),$lt:g((t,e)=>e.valueOf()<t.valueOf(),"$lt"),$lte:g((t,e)=>e.valueOf()<=t.valueOf(),"$lte"),$in:g((t,e)=>t.includes(e),"$in"),$nin:g((t,e)=>!t.includes(e),"$nin"),$regex:g((t,e)=>W(t).test(e),"$regex"),$regexFor:g((t,e)=>typeof t=="string"?W(e).test(t):W(e,t.flags).test(t.input),"$regexFor"),$bitsAllSet:g((t,e)=>(t&e)===t,"$bitsAllSet"),$bitsAllClear:g((t,e)=>(t&e)===0,"$bitsAllClear"),$bitsAnySet:g((t,e)=>(t&e)!==0,"$bitsAnySet"),$bitsAnyClear:g((t,e)=>(t&e)!==t,"$bitsAnyClear"),$el:g((t,e)=>e.some(r=>k(t,r)),"$el"),$size:g((t,e)=>e.length===t,"$size")};function k(t,e){if(Array.isArray(t))return t.includes(e);if(t instanceof RegExp)return t.test(e);if(X(t))return e.valueOf()===t.valueOf();if(se(t))return se(e);for(let r in t)if(r in ye&&!ye[r](t[r],e))return!1;return!0}g(k,"executeFieldQuery");function H(t,e,r,i={}){return Object.entries(e).every(([f,c])=>{if(f==="$and")return c.reduce((n,o)=>n&&H(t,o,r,i),!0);if(f==="$or")return c.reduce((n,o)=>n||H(t,o,r,i),!1);if(f==="$not")return!H(t,c,r,i);if(f==="$expr")return O({...i,[r]:t,_:t},c);try{let n=U(e[f])?{[f]:e[f]}:ae(e[f],`${f}.`);return Object.entries(n).every(([o,a])=>k(a,$(t,o)))}catch{return!1}})}g(H,"executeQuery");var bt=Symbol("minato.types"),gt=Symbol("minato.tables"),$t=ge;export{p as $,ge as Database,lt as Driver,p as Eval,w as Field,ht as Logger,re as Model,A as Relation,pt as RuntimeError,yt as Schema,F as Selection,gt as Tables,m as Type,bt as Types,$t as default,O as executeEval,H as executeQuery,We as executeSort,Qe as executeUpdate,ae as flatten,$ as getCell,C as hasSubquery,de as isAggrExpr,X as isComparable,Q as isEmpty,R as isEvalExpr,U as isFlat,z as isUpdateExpr,W as makeRegExp,ne as randomId,oe as unravel,dt as z};
