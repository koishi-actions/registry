import{Buffer as Ae}from"https://registry.koishi.chat/modules/buffer/index.js";import Te from"https://registry.koishi.chat/modules/process/index.js";import{deduplicate as xe,defineProperty as Ne,filterKeys as D,isNullable as Se,makeArray as A,mapValues as me,noop as Ie,omit as _,pick as Me,remove as ue}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Service as te}from"https://registry.koishi.chat/modules/cordis/index.js";import{Binary as Pe,isNullable as Fe}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{defineProperty as ie,filterKeys as Re,isNullable as X,mapValues as ne}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Binary as Be,defineProperty as re,isNullable as se,mapValues as he}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{clone as qe,deepEqual as Ke,defineProperty as _e,filterKeys as ke,isNullable as z,makeArray as S,mapValues as Qe}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{defineProperty as L,filterKeys as Ue,mapValues as de,omit as Ve}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{deepEqual as ze,defineProperty as Je,mapValues as $e,remove as He}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Context as Le,Service as Ge}from"https://registry.koishi.chat/modules/cordis/index.js";import{isNullable as ae}from"https://registry.koishi.chat/modules/cosmokit/index.js";import{Logger as ut,Schema as ht,Schema as yt}from"https://registry.koishi.chat/modules/cordis/index.js";var ve=Object.defineProperty,$=(t,e)=>ve(t,"name",{value:e,configurable:!0}),h;(t=>{t.kType=Symbol.for("minato.type"),t.Any=r("expr"),t.Boolean=r("boolean"),t.Number=r("double"),t.String=r("string"),t.Object=$(a=>re({type:"json",inner:globalThis.Object.keys(a??{}).length?he(a,l=>f(l)?l:r(l)):void 0},t.kType,!0),"Object"),t.Array=$(a=>re({type:"json",inner:a,array:!0},t.kType,!0),"Array");function e(a){if(se(a))return r("expr");if(typeof a=="number")return t.Number;if(typeof a=="string")return t.String;if(typeof a=="boolean")return t.Boolean;if(typeof a=="bigint")return r("bigint");if(a instanceof Date)return r("timestamp");if(Be.is(a))return r("binary");if(globalThis.Array.isArray(a))return(0,t.Array)(a.length?e(a[0]):void 0);if(typeof a=="object")return r("json");throw new TypeError(`invalid primitive: ${a}`)}t.fromPrimitive=e,$(e,"fromPrimitive");function r(a){if(f(a))return a;if(a==="array")return(0,t.Array)();if(a==="object")return(0,t.Object)();if(typeof a=="string")return re({type:a},t.kType,!0);if(a.type)return a.type;if(a.expr?.[t.kType])return a.expr[t.kType];throw new TypeError(`invalid field: ${a}`)}t.fromField=r,$(r,"fromField");function i(a,l){return M(a)?a[t.kType]??l??r("expr"):e(a)}t.fromTerm=i,$(i,"fromTerm");function s(a,l){return a.map(p=>i(p)).find(p=>p.type!=="expr")??l??r("expr")}t.fromTerms=s,$(s,"fromTerms");function f(a){return a?.[t.kType]===!0}t.isType=f,$(f,"isType");function c(a){return a?.type==="json"&&a?.array}t.isArray=c,$(c,"isArray");function n(a,l){if(!a?.inner)return;if(c(a))return a.inner;if(se(l))return;if(a.inner[l])return a.inner[l];if(l.includes("."))return l.split(".").reduce((y,b)=>n(y,b),a);let p=globalThis.Object.entries(a.inner).filter(([y])=>y.startsWith(`${l}.`)).map(([y,b])=>[y.slice(l.length+1),b]);return p.length?(0,t.Object)(globalThis.Object.fromEntries(p)):void 0}t.getInner=n,$(n,"getInner");function o(a,l,p){return!se(a)&&l?.inner?t.isArray(l)?a.map(y=>p(y,t.getInner(l))).filter(y=>!l.ignoreNull||!W(y)):l.ignoreNull&&W(a)?null:he(a,(y,b)=>p(y,t.getInner(l,b))):a}t.transform=o,$(o,"transform")})(h||(h={}));var T;(t=>{let e=Symbol("minato.relation");t.Type=["oneToOne","oneToMany","manyToOne","manyToMany"];function r(...c){return"_"+c.sort().join("_")}t.buildAssociationTable=r,$(r,"buildAssociationTable");function i(c,n){return`${n}.${c}`}t.buildAssociationKey=i,$(i,"buildAssociationKey");function s(c,n){return[c,n].sort().join("_")}t.buildSharedKey=s,$(s,"buildSharedKey");function f(c,n,o,a,l){let p=c.shared?typeof c.shared=="string"?{[c.shared]:c.shared}:Array.isArray(c.shared)?Object.fromEntries(c.shared.map(d=>[d,d])):c.shared:{},y=c.fields??(l||c.type==="manyToOne"||c.type==="oneToOne"&&(o.name===a.name||!S(a.primary).every(d=>!a.fields[d]?.nullable))?S(a.primary).map(d=>`${n}.${d}`):o.primary),b={type:c.type,table:c.table??a.name,fields:S(y),shared:p,references:S(c.references??a.primary),required:c.type!=="manyToOne"&&o.name!==a.name&&S(y).every(d=>!o.fields[d]?.nullable||S(o.primary).includes(d))};Object.entries(p).forEach(([d,O])=>{b.fields=b.fields.filter(w=>w!==d),b.references=b.references.filter(w=>w!==O)});let u={type:b.type==="oneToMany"?"manyToOne":b.type==="manyToOne"?"oneToMany":b.type,table:o.name,fields:b.references,references:b.fields,shared:Object.fromEntries(Object.entries(p).map(([d,O])=>[O,d])),required:b.type!=="oneToMany"&&b.references.every(d=>!a.fields[d]?.nullable||S(a.primary).includes(d))};return u.required&&(b.required=!1),[b,u]}t.parse=f,$(f,"parse")})(T||(T={}));var E;(t=>{t.number=["integer","unsigned","float","double","decimal"],t.string=["char","string","text"],t.boolean=["boolean"],t.date=["timestamp","date","time"],t.object=["list","json"];let e=Symbol("minato.newtype"),r=/^(\w+)(?:\((.+)\))?$/;function i(c){if(typeof c=="function")throw new TypeError("view field is not supported");if(typeof c!="string")return{initial:null,deftype:c.type,...c,type:h.fromField(c.type)};let n=r.exec(c);if(!n)throw new TypeError("invalid field definition");let o=n[1],a=(n[2]||"").split(","),l={deftype:o,type:h.fromField(o)};return l.initial===void 0&&(l.initial=s(o)),o==="decimal"?(l.precision=+a[0],l.scale=+a[1]):a[0]&&(l.length=+a[0]),l}t.parse=i,$(i,"parse");function s(c,n){if(n===void 0){if(t.number.includes(c))return 0;if(t.string.includes(c))return"";if(c==="list")return[];if(c==="json")return{}}return n}t.getInitial=s,$(s,"getInitial");function f(c){return!!c&&!c.deprecated&&!c.relation&&c.deftype!=="expr"}t.available=f,$(f,"available")})(E||(E={}));var oe=class{constructor(t){this.name=t,this.autoInc=!1,this.primary="id",this.unique=[],this.indexes=[],this.foreign={}}static{$(this,"Model")}fields={};migrations=new Map;extend(t={},e={}){let{primary:r,autoInc:i,unique:s=[],indexes:f=[],foreign:c,callback:n}=e;this.primary=r||this.primary,this.autoInc=i||this.autoInc,s.forEach(o=>this.unique.includes(o)||this.unique.push(o)),f.map(o=>this.parseIndex(o)).forEach(o=>this.indexes.some(a=>Ke(a,o))||this.indexes.push(o)),Object.assign(this.foreign,c),n&&this.migrations.set(n,Object.keys(t));for(let o in t)this.fields[o]=E.parse(t[o]),this.fields[o].deprecated=!!n;typeof this.primary=="string"&&this.fields[this.primary]?.deftype==="primary"&&(this.autoInc=!0),this.checkIndex(this.primary),this.unique.forEach(o=>this.checkIndex(o)),this.indexes.forEach(o=>this.checkIndex(o))}parseIndex(t){return typeof t=="string"||Array.isArray(t)?{name:`index:${this.name}:`+S(t).join("+"),unique:!1,keys:Object.fromEntries(S(t).map(e=>[e,"asc"]))}:{name:t.name??`index:${this.name}:`+Object.keys(t.keys).join("+"),unique:t.unique??!1,keys:t.keys}}checkIndex(t){for(let e of typeof t=="string"||Array.isArray(t)?S(t):Object.keys(t.keys))if(!this.fields[e])throw new TypeError(`missing field definition for index key "${e}"`)}resolveValue(t,e){if(z(e))return e;if(typeof t=="string"&&(t=this.fields[t]),t&&(t=h.fromField(t)),t?.type==="time"){let r=new Date(0);return r.setHours(e.getHours(),e.getMinutes(),e.getSeconds(),e.getMilliseconds()),r}else if(t?.type==="date"){let r=new Date(e);return r.setHours(0,0,0,0),r}return e}resolveModel(t,e){if(e||(e=this.getType()),z(t)||!e.inner)return t;if(h.isArray(e)&&Array.isArray(t))return t.map(i=>this.resolveModel(i,h.getInner(e)));let r={};for(let i in t){let s=h.getInner(e,i);!s||z(t[i])?r[i]=t[i]:s.type!=="json"?r[i]=this.resolveValue(s,t[i]):M(t[i])?r[i]=t[i]:s.inner&&h.isArray(s)&&Array.isArray(t[i])?r[i]=t[i].map(f=>this.resolveModel(f,h.getInner(s))):s.inner?r[i]=this.resolveModel(t[i],s):r[i]=t[i]}return r}format(t,e=!0,r="",i={}){let s=Object.keys(this.fields).filter(f=>!this.fields[f].relation);return Object.entries(t).map(([f,c])=>{if(f=r+f,c===void 0)return;if(s.includes(f)){i[f]=c;return}if(s.find(o=>f.startsWith(o+".")))i[f]=c;else if(C(c)){if(e&&(typeof c!="object"||Object.keys(c).length))throw new TypeError(`unknown field "${f}" in model ${this.name}`)}else this.format(c,e,f+".",i)}),e&&r===""?this.resolveModel(i):i}parse(t,e=!0,r="",i={}){let s=Object.keys(this.fields).filter(f=>!this.fields[f].relation);e&&r===""&&Object.assign(i,le(Object.fromEntries(s.filter(f=>f.includes(".")).map(f=>[f.slice(0,f.lastIndexOf(".")),{}]))));for(let f in t){let c=i,n=f.split(".").reverse();for(let o=n.length-1;o>0;o--){let a=n[o];c=c[a]??={}}if(f in t){let o=r+f,a=t[f];if(s.find(p=>o===p||o.startsWith(p+".")))c[n[0]]=a;else if(C(a)){if(e)throw new TypeError(`unknown field "${o}" in model ${this.name}`);c[n[0]]=a}else this.parse(a,e,o+".",c[n[0]]??={})}}return e&&r===""?this.resolveModel(i):i}create(t){let e={},r=S(this.primary);for(let i in this.fields){if(!E.available(this.fields[i]))continue;let{initial:s}=this.fields[i];!r.includes(i)&&!z(s)&&(e[i]=qe(s))}return this.parse({...e,...t})}availableFields(){return ke(this.fields,(t,e)=>E.available(e))}getType(t){return this.type||_e(this,"type",h.Object(Qe(this.fields,e=>h.fromField(e)))),t?h.getInner(this.type,t):this.type}};function M(t){return t&&Object.keys(t).some(e=>e.startsWith("$"))}$(M,"isEvalExpr");var J=M;function je(t){return t.$||t.$select}$(je,"isAggrExpr");function H(t){return M(t)?Object.entries(t).filter(([e])=>e.startsWith("$")).some(([e,r])=>X(r)||Z(r)?!1:e==="$exec"?!0:M(r)?H(r):Array.isArray(r)?r.some(i=>H(i)):typeof r=="object"?Object.values(r).some(i=>H(i)):!1):!1}$(H,"hasSubquery");var We=Symbol("expr");var m=$((t,e,r)=>ie(ie({["$"+t]:e},We,!0),h.kType,r),"Eval"),I=Object.create(null);I.$=Y;function N(t,e,r){return I[`$${t}`]=e,i=>m(t,i,typeof r=="function"?r(i):r)}$(N,"unary");function v(t,e,r){return I[`$${t}`]=e,(...i)=>m(t,i,typeof r=="function"?r(...i):r)}$(v,"multary");function q(t,e){return I[`$${t}`]=(r,i)=>{let s=j(i,r[0]),f=j(i,r[1]);return X(s)||X(f)?!0:e(s.valueOf(),f.valueOf())},(...r)=>m(t,r,h.Boolean)}$(q,"comparator");m.switch=(t,e)=>m("switch",{branches:t,default:e},h.fromTerm(t[0]));I.$switch=(t,e)=>{for(let r of t.branches)if(j(e,r.case))return j(e,r.then);return j(e,t.default)};m.ignoreNull=t=>(t.$ignoreNull=!0,t[h.kType].ignoreNull=!0,t);m.select=v("select",(t,e)=>t.map(r=>j(e,r)),h.Array());m.query=(t,e,r=!0)=>({$expr:r,...e});m.exec=N("exec",(t,e)=>t.driver.executeSelection(t,e),t=>h.fromTerm(t.args[0]));m.if=v("if",([t,e,r],i)=>j(i,t)?j(i,e):j(i,r),(t,e,r)=>h.fromTerm(e));m.ifNull=v("ifNull",([t,e],r)=>j(r,t)??j(r,e),t=>h.fromTerm(t));m.add=v("add",(t,e)=>t.reduce((r,i)=>r+j(e,i),0),h.Number);m.mul=m.multiply=v("multiply",(t,e)=>t.reduce((r,i)=>r*j(e,i),1),h.Number);m.sub=m.subtract=v("subtract",([t,e],r)=>j(r,t)-j(r,e),h.Number);m.div=m.divide=v("divide",([t,e],r)=>j(r,t)/j(r,e),h.Number);m.mod=m.modulo=v("modulo",([t,e],r)=>j(r,t)%j(r,e),h.Number);m.abs=N("abs",(t,e)=>Math.abs(j(e,t)),h.Number);m.floor=N("floor",(t,e)=>Math.floor(j(e,t)),h.Number);m.ceil=N("ceil",(t,e)=>Math.ceil(j(e,t)),h.Number);m.round=N("round",(t,e)=>Math.round(j(e,t)),h.Number);m.exp=N("exp",(t,e)=>Math.exp(j(e,t)),h.Number);m.log=v("log",([t,e],r)=>Math.log(j(r,t))/Math.log(j(r,e??Math.E)),h.Number);m.pow=m.power=v("power",([t,e],r)=>Math.pow(j(r,t),j(r,e)),h.Number);m.random=()=>m("random",{},h.Number);I.$random=()=>Math.random();m.eq=q("eq",(t,e)=>t===e);m.ne=q("ne",(t,e)=>t!==e);m.gt=q("gt",(t,e)=>t>e);m.ge=m.gte=q("gte",(t,e)=>t>=e);m.lt=q("lt",(t,e)=>t<e);m.le=m.lte=q("lte",(t,e)=>t<=e);m.in=(t,e)=>m("in",[Array.isArray(t)?m.select(...t):t,e],h.Boolean);I.$in=([t,e],r)=>{let i=j(r,t),s=j(r,e);return typeof i=="object"?s.includes(i)||s.map(JSON.stringify).includes(JSON.stringify(i)):s.includes(i)};m.nin=(t,e)=>m("nin",[Array.isArray(t)?m.select(...t):t,e],h.Boolean);I.$nin=([t,e],r)=>{let i=j(r,t),s=j(r,e);return typeof i=="object"?!s.includes(i)&&!s.map(JSON.stringify).includes(JSON.stringify(i)):!s.includes(i)};m.concat=v("concat",(t,e)=>t.map(r=>j(e,r)).join(""),h.String);m.regex=v("regex",([t,e,r],i)=>V(j(i,e),r).test(j(i,t)),h.Boolean);m.and=v("and",(t,e)=>{let r=h.fromTerms(t,h.Boolean);if(E.boolean.includes(r.type))return t.every(i=>j(e,i));if(E.number.includes(r.type))return t.map(i=>j(e,i)).reduce((i,s)=>i&s);if(r.type==="bigint")return t.map(i=>BigInt(j(e,i)??0)).reduce((i,s)=>i&s)},(...t)=>h.fromTerms(t,h.Boolean));m.or=v("or",(t,e)=>{let r=h.fromTerms(t,h.Boolean);if(E.boolean.includes(r.type))return t.some(i=>j(e,i));if(E.number.includes(r.type))return t.map(i=>j(e,i)).reduce((i,s)=>i|s);if(r.type==="bigint")return t.map(i=>BigInt(j(e,i)??0)).reduce((i,s)=>i|s)},(...t)=>h.fromTerms(t,h.Boolean));m.not=N("not",(t,e)=>{let r=h.fromTerms([t],h.Boolean);if(E.boolean.includes(r.type))return!j(e,t);if(E.number.includes(r.type))return~j(e,t);if(r.type==="bigint")return~BigInt(j(e,t)??0)},t=>h.fromTerms([t],h.Boolean));m.xor=v("xor",(t,e)=>{let r=h.fromTerms(t,h.Boolean);if(E.boolean.includes(r.type))return t.map(i=>j(e,i)).reduce((i,s)=>i!==s);if(E.number.includes(r.type))return t.map(i=>j(e,i)).reduce((i,s)=>i^s);if(r.type==="bigint")return t.map(i=>BigInt(j(e,i)??0)).reduce((i,s)=>i^s)},(...t)=>h.fromTerms(t,h.Boolean));m.literal=v("literal",([t,e])=>t,(t,e)=>e?h.fromField(e):h.fromTerm(t));m.number=N("number",(t,e)=>{let r=j(e,t);return r instanceof Date?Math.floor(r.valueOf()/1e3):Number(r)},h.Number);var Oe=$((t,e)=>{let r=h.fromTerm(t);return r=h.getInner(r)??r,e&&r.type==="expr"?e:r},"unwrapAggr");m.sum=N("sum",(t,e)=>Array.isArray(e)?e.reduce((r,i)=>r+F(t,i),0):Array.from(j(e,t)).reduce((r,i)=>r+i,0),h.Number);m.avg=N("avg",(t,e)=>{if(Array.isArray(e))return e.reduce((r,i)=>r+F(t,i),0)/e.length;{let r=Array.from(j(e,t));return r.reduce((i,s)=>i+s,0)/r.length}},h.Number);m.max=N("max",(t,e)=>Array.isArray(e)?e.map(r=>F(t,r)).reduce((r,i)=>r>i?r:i,-1/0):Array.from(j(e,t)).reduce((r,i)=>r>i?r:i,-1/0),t=>Oe(t,h.Number));m.min=N("min",(t,e)=>Array.isArray(e)?e.map(r=>F(t,r)).reduce((r,i)=>r<i?r:i,1/0):Array.from(j(e,t)).reduce((r,i)=>r<i?r:i,1/0),t=>Oe(t,h.Number));m.count=N("count",(t,e)=>new Set(e.map(r=>F(t,r))).size,h.Number);ie(m,"length",N("length",(t,e)=>Array.isArray(e)?e.map(r=>F(t,r)).length:Array.from(j(e,t)).length,h.Number));I.$object=(t,e)=>ne(t,r=>F(r,e));m.object=t=>{if(t.$model){let e=Object.entries(t.$model.fields),r=t.$prefix;return t=Object.fromEntries(e.filter(([,i])=>E.available(i)).filter(([i])=>i.startsWith(r)).map(([i])=>[i.slice(r.length),t[i.slice(r.length)]])),Object.assign(m("object",t,h.Object(ne(t,i=>h.fromTerm(i)))),t)}return t=Re(t,e=>e!=="$object"),Object.assign(m("object",t,h.Object(ne(t,e=>h.fromTerm(e)))),t)};m.array=N("array",(t,e)=>Array.isArray(e)?e.map(r=>F(t,r)).filter(r=>!t[h.kType]?.ignoreNull||!W(r)):Array.from(j(e,t)).filter(r=>!t[h.kType]?.ignoreNull||!W(r)),t=>h.Array(h.fromTerm(t)));m.get=v("get",([t,e],r)=>j(r,t)?.[j(r,e)],(t,e)=>h.getInner(h.fromTerm(t),e)??h.Any);function Y(t,e){if(typeof t=="string")return Y(["_",t],e);let[r,i]=t,s=e[r];if(!s)return s;if(i in s)return s[i];let f=Object.keys(s).find(n=>i.startsWith(n+"."))||i.split(".",1)[0],c=i.slice(f.length+1).split(".").filter(Boolean);c.unshift(f);for(let n of c)if(s=s[n],!s)return s;return s}$(Y,"getRecursive");function fe(t,e){for(let r in t)if(r in I)return I[r](t[r],e);return t}$(fe,"executeEvalExpr");function F(t,e){return typeof t=="string"?Y(t,e):fe(t,e)}$(F,"executeAggr");function j(t,e){return Z(e)||X(e)?e:Array.isArray(e)?e.map(r=>j(t,r)):fe(e,t)}$(j,"executeEval");function De(t,e,r){for(let i in e){let s=t,f=i.split("."),c=f.pop();for(let n of f)s=s[n]||={};s[c]=j({[r]:t,_:t},e[i])}return t}$(De,"executeUpdate");function Z(t){return typeof t=="string"||typeof t=="number"||typeof t=="boolean"||typeof t=="bigint"||t instanceof Date}$(Z,"isComparable");function C(t){return!t||typeof t!="object"||M(t)||Object.keys(t).length===0||Array.isArray(t)||t instanceof Date||t instanceof RegExp||Pe.isSource(t)}$(C,"isFlat");var ye="abcdefghijklmnopqrstuvwxyz";function ce(){return Array(8).fill(0).map(()=>ye[Math.floor(Math.random()*ye.length)]).join("")}$(ce,"randomId");function V(t,e){return t instanceof RegExp&&!e?t:new RegExp(t.source??t,e??t.flags)}$(V,"makeRegExp");function le(t,e){let r={};for(let i in t){let s=r,f=i.split(".").reverse();for(let c=f.length-1;c>0;c--){let n=f[c];s=s[n]??={},e&&(s=e(s))}s[f[0]]=t[i]}return r}$(le,"unravel");function pe(t,e="",r=C){let i={};for(let s in t){let f=t[s];r(f)?i[`${e}${s}`]=f:Object.assign(i,pe(f,`${e}${s}.`,r))}return i}$(pe,"flatten");function g(t,e){if(e in t)return t[e];if(e.includes(".")){let r=e.indexOf(".");return g(t[e.slice(0,r)]??{},e.slice(r+1))}else return t[e]}$(g,"getCell");function W(t){if(Fe(t))return!0;if(typeof t!="object")return!1;for(let e in t)if(!W(t[e]))return!1;return!0}$(W,"isEmpty");var R=$((t,e={},r="",i,s)=>new Proxy(e,{get(f,c){if(c==="$prefix")return r;if(c==="$model")return i;if(typeof c=="symbol"||c in f||c.startsWith("$"))return Reflect.get(f,c);if(s)return h.isArray(e?.[h.kType])&&Number.isInteger(+c)?R(t,m.get(e,+c),"",i,m.get(e,+c)):R(t,m.get(s,`${r}${c}`),`${r}${c}.`,i,s);let n,o=i?.fields[r+c];if(h.isArray(e?.[h.kType])&&Number.isInteger(+c))return n=h.getInner(e?.[h.kType])??h.fromField("expr"),R(t,m.get(e,+c),"",i,m.get(e,+c));h.getInner(e?.[h.kType],c)?n=h.getInner(e?.[h.kType],c):o?n=h.fromField(o):Object.keys(i?.fields).some(l=>l.startsWith(`${r}${c}.`))?n=h.Object(Object.fromEntries(Object.entries(i?.fields).filter(([l])=>l.startsWith(`${r}${c}`)).map(([l,p])=>[l.slice(r.length+c.length+1),h.fromField(p)]))):n=i?.getType(`${r}${c}`)??h.fromField("expr");let a=R(t,m("",[t,`${r}${c}`],n),`${r}${c}.`,i);return!o&&Object.keys(i?.fields).some(l=>l.startsWith(`${r}${c}.`))?R(t,m.object(a),`${r}${c}.`,i):a}}),"createRow"),be=class{static{$(this,"Executable")}row;model;driver;constructor(t,e){Object.assign(this,e),L(this,"driver",t),L(this,"model",t.model(this.table)),L(this,"row",R(this.ref,m.object(R(this.ref,{},"",this.model)),"",this.model))}isCallaback(t){if(typeof t!="function")return!1;let e=t(this.row);return M(Ve(e,["$object"]))}resolveQuery(t={}){if(typeof t=="function"){let e=t(this.row);return e.$expr?e:M(e)?{$expr:e}:e}if(Array.isArray(t)||t instanceof RegExp||["string","number","bigint"].includes(typeof t)){let{primary:e}=this.model;if(Array.isArray(e))throw new TypeError("invalid shorthand for composite primary key");return{[e]:t}}return t}resolveField(t){if(typeof t=="string")return this.row[t];if(typeof t=="function")return t(this.row);if(M(t))return t;throw new TypeError("invalid field definition")}resolveFields(t){if(typeof t=="function"&&(t=t(this.row)),typeof t=="string"&&(t=[t]),Array.isArray(t)){let e=Object.keys(this.model.fields),r=t.flatMap(i=>this.model.fields[i]?[[i,this.row[i]]]:e.some(s=>s.startsWith(i+"."))?e.filter(s=>s.startsWith(i+".")).map(s=>[s,this.row[s]]):[[i,i.split(".").reduce((s,f)=>s[f],this.row)]]);return Object.fromEntries(r)}else{let e=Object.entries(t).flatMap(([r,i])=>{if(r.startsWith("$"))return[];let s=this.resolveField(i);return s.$object&&!h.fromTerm(s).ignoreNull?Object.entries(s.$object).map(([f,c])=>[`${r}.${f}`,c]):[[r,s]]});return Object.fromEntries(e)}}async execute(){return await this.driver.database.prepared(),await this.driver._ensureSession(),this.driver[this.type](this,...this.args)}},B=class U extends be{static{$(this,"Selection")}tables={};constructor(e,r,i){super(e,{type:"get",ref:ce(),table:r,query:null,args:[{sort:[],limit:1/0,offset:0,group:void 0,having:m.and(),optional:{}}]}),this.tables[this.ref]=this.model,this.query=this.resolveQuery(i),typeof r!="string"&&Object.assign(this.tables,r.tables)}where(e){return this.query.$and||=[],this.query.$and.push(this.resolveQuery(e)),this}limit(...e){return e.length>1&&this.offset(e.shift()),this.args[0].limit=e[0],this}offset(e){return this.args[0].offset=e,this}orderBy(e,r="asc"){return this.args[0].sort.push([this.resolveField(e),r]),this}groupBy(e,...r){this.args[0].fields=this.resolveFields(e),this.args[0].group=Object.keys(this.args[0].fields);let i=this.isCallaback(r[0])?void 0:r.shift();return Object.assign(this.args[0].fields,this.resolveFields(i||{})),r[0]&&this.having(r[0]),new U(this.driver,this)}having(e){return this.args[0].having.$and.push(this.resolveField(e)),this}project(e){return this.args[0].fields=this.resolveFields(e),new U(this.driver,this)}join(e,r,i=()=>m.and(),s=!1){let f=Object.fromEntries(Object.entries(this.model.fields).filter(([n,o])=>E.available(o)&&!n.startsWith(e+".")).map(([n])=>[n,o=>g(o[this.ref],n)])),c=Object.fromEntries(Object.entries(r.model.fields).filter(([n,o])=>E.available(o)||E.available(this.model.fields[`${e}.${n}`])).map(([n])=>[n,o=>E.available(this.model.fields[`${e}.${n}`])?g(o[this.ref],`${e}.${n}`):g(o[e],n)]));return s?this.driver.database.join({[this.ref]:this,[e]:r},n=>i(n[this.ref],n[e]),{[this.ref]:!1,[e]:!0}).project({...f,[e]:n=>m.ignoreNull(m.object(de(c,o=>o(n))))}):this.driver.database.join({[this.ref]:this,[e]:r},n=>i(n[this.ref],n[e])).project({...f,[e]:n=>m.ignoreNull(m.object(de(c,o=>o(n))))})}_action(e,...r){return new be(this.driver,{...this,type:e,args:r})}evaluate(e){let r=new U(this.driver,this);e||(e=$(s=>m.array(m.object(s)),"callback"));let i=Array.isArray(e)?m.select(...e.map(s=>this.resolveField(s))):this.resolveField(e);return je(i)&&L(i,h.kType,h.Array(h.fromTerm(i))),m.exec(r._action("eval",i))}async execute(e){if(typeof e=="function")return new U(this.driver,this)._action("eval",this.resolveField(e)).execute();if(Array.isArray(e)?e={fields:e}:e||(e={}),e.fields&&this.project(e.fields),e.limit!==void 0&&this.limit(e.limit),e.offset!==void 0&&this.offset(e.offset),e.sort)for(let i in e.sort)this.orderBy(i,e.sort[i]);let r=await super.execute();return e.fields?r.map(i=>Ue(i,s=>e.fields.some(f=>f===s||f.startsWith(`${s}.`)))):r}};(t=>{function e(r){return r&&!!r.tables}t.is=e,$(e,"is")})(B||(B={}));function Ce(t,e,r){let{limit:i,offset:s,sort:f}=e;return t.sort((c,n)=>{for(let[o,a]of f){let l=a==="asc"?1:-1,p=j({[r]:c,_:c},o),y=j({[r]:n,_:n},o);if(p<y)return-l;if(p>y)return l}return 0}),t.slice(s,s+i)}$(Ce,"executeSort");function k(t,e){return typeof e=="function"?r=>{let i=e(r);return{$expr:!0,...t,...i.$expr?i:{$expr:i}}}:r=>({$expr:!0,...t,...e})}$(k,"mergeQuery");var we=class P extends te{static{$(this,"Database")}static[te.provide]="model";static[te.immediate]=!0;static transact=Symbol("minato.transact");static migrate=Symbol("minato.migrate");tables=Object.create(null);drivers=[];types=Object.create(null);_driver;stashed=new Set;prepareTasks=Object.create(null);migrateTasks=Object.create(null);async connect(e,...r){this.ctx.plugin(e,r[0]),await this.ctx.start()}refresh(){for(let e in this.tables)this.prepareTasks[e]=this.prepare(e)}async prepared(){this[P.migrate]||await Promise.all(Object.values(this.prepareTasks))}getDriver(e){if(B.is(e))return e.driver;let r=this.tables[e];if(!r)throw new Error(`cannot resolve table "${e}"`);return r.ctx?.get("database")?._driver}async prepare(e){if(this.stashed.add(e),await this.prepareTasks[e],await Promise.resolve(),!this.stashed.delete(e))return;let r=this.getDriver(e);if(!r)return;let{fields:i}=r.model(e);Object.values(i).forEach(s=>s?.transformers?.forEach(f=>r.define(f))),await r.prepare(e),await r.prepareIndexes(e)}extend(e,r,i={}){let s=this.tables[e];s||(s=this.tables[e]=new oe(e)),Object.entries(r).forEach(([f,c])=>{let n=[];this.parseField(c,n,void 0,o=>c=r[f]=o),typeof c=="object"&&(c.transformers=n)}),s.extend(r,i),A(s.primary).every(f=>f in r)&&Ne(s,"ctx",this.ctx),Object.entries(r).forEach(([f,c])=>{if(!T.Type.includes(c.type))return;let n=!c.fields&&A(s.primary).includes(f),[o,a]=T.parse(c,f,s,this.tables[c.table??f],n),l=this.tables[o.table];if(!l)throw new Error(`relation table ${o.table} does not exist`);if((s.fields[f]=E.parse("expr")).relation=o,c.target&&((l.fields[c.target]??=E.parse("expr")).relation=a),o.type==="oneToOne"||o.type==="manyToOne")o.fields.forEach((p,y)=>{s.fields[p]??={...l.fields[o.references[y]]},o.required||(s.fields[p].nullable=!0,s.fields[p].initial=null)});else if(o.type==="manyToMany"){let p=T.buildAssociationTable(o.table,e);if(this.tables[p])return;let y=Object.entries(o.shared).map(([d,O])=>[T.buildSharedKey(d,O),s.fields[d].deftype]),b=o.fields.map(d=>[T.buildAssociationKey(d,e),s.fields[d].deftype]),u=o.references.map(d=>[T.buildAssociationKey(d,o.table),l.fields[d]?.deftype]);this.extend(p,{...Object.fromEntries([...y,...b,...u]),[e]:{type:"manyToOne",table:e,fields:[...y,...b].map(d=>d[0]),references:[...Object.keys(o.shared),...o.fields]},[o.table]:{type:"manyToOne",table:o.table,fields:[...y,...u].map(d=>d[0]),references:[...Object.values(o.shared),...o.references]}},{primary:[...y,...b,...u].map(d=>d[0])})}}),(Array.isArray(s.primary)||s.fields[s.primary].relation)&&(s.primary=xe(A(s.primary).map(f=>s.fields[f].relation?.fields||f).flat())),s.unique=s.unique.map(f=>typeof f=="string"?s.fields[f].relation?.fields||f:f.map(c=>s.fields[c].relation?.fields||c).flat()),this.prepareTasks[e]=this.prepare(e),this.ctx.emit("model",e)}_parseField(e,r=[],i,s){if(e==="object")return i?.({}),s?.({initial:{},deftype:"json",type:h.Object()}),h.Object();if(e==="array")return i?.([]),s?.({initial:[],deftype:"json",type:h.Array()}),h.Array();if(typeof e=="string"&&this.types[e])return r.push({types:[e],load:this.types[e].load,dump:this.types[e].dump},...this.types[e].transformers??[]),i?.(this.types[e].initial),s?.({...this.types[e],type:e}),h.fromField(e);if(typeof e=="string")return i?.(E.getInitial(e.split("(")[0])),s?.(e),h.fromField(e.split("(")[0]);if(typeof e=="object"&&e.type==="object"){let f=e.inner?le(e.inner,o=>(o.type="object",o.inner??={})):Object.create(null),c=Object.create(null),n=h.Object(me(f,(o,a)=>this.parseField(o,r,l=>c[a]=l)));return i?.(E.getInitial("json",c)),s?.({initial:E.getInitial("json",c),...e,deftype:"json",type:n}),n}else if(typeof e=="object"&&e.type==="array"){let f=e.inner?h.Array(this.parseField(e.inner,r)):h.Array();return i?.([]),s?.({initial:[],...e,deftype:"json",type:f}),f}else return typeof e=="object"&&this.types[e.type]?(r.push({types:[e.type],load:this.types[e.type].load,dump:this.types[e.type].dump},...this.types[e.type].transformers??[]),i?.(e.initial===void 0?this.types[e.type].initial:e.initial),s?.({initial:this.types[e.type].initial,...e}),h.fromField(e.type)):(i?.(E.getInitial(e.type,e.initial)),s?.(e),h.fromField(e.type))}parseField(e,r=[],i,s){let f,c=this._parseField(e,r,i,n=>(f=n,s?.(n)));if(typeof e=="object"&&e.load&&e.dump){c.inner&&(c=h.fromField(this.define({..._(f,["load","dump"]),type:c})));let n=this.define({...e,deftype:f.deftype,type:c.type});return r.push({types:[n],load:e.load,dump:e.dump}),i?.(e.initial),s?.({...e,deftype:f.deftype??this.types[c.type]?.deftype??c.type,initial:f.initial,type:n}),h.fromField(n)}return typeof f=="object"&&s?.({...f,deftype:f.deftype??this.types[c.type]?.deftype??c?.type}),c}define(e,r){if(typeof e=="object"&&(r=e,e=void 0),e&&this.types[e])throw new Error(`type "${e}" already defined`);if(!e)for(;this.types[e="_define_"+ce()];);let i=[],s=this._parseField(r,i,void 0,f=>r=f);return r.transformers=i,this.ctx.effect(()=>(this.types[e]={...r},this.types[e].deftype??=this.types[r.type]?.deftype??s.type,()=>delete this.types[e])),e}migrate(e,r,i){this.extend(e,r,{callback:i})}select(e,r,i){let s=new B(this.getDriver(e),e,r);if(typeof e!="string")return s;let f=i===null,c=!!i?.$assoc,n=typeof r=="function"?r:()=>r,o=this.tables[e].fields;i&&(i=D(i,a=>!!o[a]?.relation));for(let a in{...s.query,...s.query.$not})o[a]?.relation&&(s.query[a]===null&&!o[a].relation.required&&(s.query[a]=Object.fromEntries(o[a].relation.references.map(l=>[l,null]))),s.query[a]&&typeof s.query[a]!="function"&&typeof s.query[a]=="object"&&Object.keys(s.query[a]).every(l=>o[a].relation.fields.includes(`${a}.${l}`))&&(Object.entries(s.query[a]).forEach(([l,p])=>s.query[`${a}.${l}`]=p),delete s.query[a]),s.query.$not?.[a]===null&&!o[a].relation.required&&(s.query.$not[a]=Object.fromEntries(o[a].relation.references.map(l=>[l,null]))),s.query.$not?.[a]&&typeof s.query.$not[a]!="function"&&typeof s.query.$not[a]=="object"&&Object.keys(s.query.$not[a]).every(l=>o[a].relation.fields.includes(`${a}.${l}`))&&(Object.entries(s.query.$not[a]).forEach(([l,p])=>s.query.$not[`${a}.${l}`]=p),delete s.query.$not[a]),(!i||!Object.getOwnPropertyNames(i).includes(a))&&((i??={})[a]=!0));if(s.query=_(s.query,Object.keys(i??{})),Object.keys(s.query.$not??{}).length&&(s.query.$not=_(s.query.$not,Object.keys(i??{})),Object.keys(s.query.$not).length===0&&Reflect.deleteProperty(s.query,"$not")),i&&typeof i=="object"){if(typeof e!="string")throw new Error("cannot include relations on derived selection");let a=[],l=$((p,y)=>{let b=n(p.row),u=b[y]!==void 0?b[y]:b.$not?.[y]!==void 0?{$not:b.$not?.[y]}:void 0;return u===void 0?p:p.where(this.transformRelationQuery(e,p.row,y,u))},"applyQuery");for(let p in i){if(!i[p]||!o[p]?.relation)continue;let y=o[p].relation,b=this.tables[y.table];if(y.type==="oneToOne"||y.type==="manyToOne")s=f?s:s.join(p,this.select(y.table,typeof i[p]=="object"?D(i[p],u=>!b.fields[u]?.relation):{},typeof i[p]=="object"?D(i[p],u=>!!b.fields[u]?.relation):i[p]),(u,d)=>m.and(...y.fields.map((O,w)=>m.eq(u[O],d[y.references[w]]))),!c),s=l(s,p);else if(y.type==="oneToMany")s=f?s:s.join(p,this.select(y.table,typeof i[p]=="object"?D(i[p],u=>!b.fields[u]?.relation):{},typeof i[p]=="object"?D(i[p],u=>!!b.fields[u]?.relation):i[p]),(u,d)=>m.and(...y.fields.map((O,w)=>m.eq(u[O],d[y.references[w]]))),!0),s=l(s,p),s=f?s:s.groupBy([...Object.entries(o).filter(([u,d])=>!a.some(O=>u.startsWith(`${O}.`))&&E.available(d)).map(([u])=>u),...a],{[p]:u=>m.ignoreNull(m.array(u[p]))});else if(y.type==="manyToMany"){let u=T.buildAssociationTable(y.table,e),d=y.fields.map(w=>T.buildAssociationKey(w,e)),O=Object.entries(y.shared).map(([w,x])=>[T.buildSharedKey(w,x),{field:w,reference:x}]);s=f?s:s.join(p,this.select(u,{},{$assoc:!0,[y.table]:i[p]}),(w,x)=>m.and(...O.map(([K,ee])=>m.eq(w[ee.field],x[K])),...y.fields.map((K,ee)=>m.eq(w[K],x[d[ee]]))),!0),s=l(s,p),s=f?s:s.groupBy([...Object.entries(o).filter(([w,x])=>!a.some(K=>w.startsWith(`${K}.`))&&E.available(x)).map(([w])=>w),...a],{[p]:w=>m.ignoreNull(m.array(w[p][y.table]))})}a.push(p)}}return s}join(e,r=(...s)=>m.and(),i){let s=e;Array.isArray(s)&&(e=Object.fromEntries(s.map(o=>[o,this.select(o)])));let f=me(e,o=>typeof o=="string"?this.select(o):o);if(Object.keys(f).length===0)throw new Error("no tables to join");let c=new Set(Object.values(f).map(o=>o.driver[P.transact]??o.driver));if(c.size!==1)throw new Error("cannot join tables from different drivers");if(Object.keys(f).length===2&&(i?.[0]||i?.[Object.keys(f)[0]])){if(i[1]||i[Object.keys(f)[1]])throw new Error("full join is not supported");f=Object.fromEntries(Object.entries(f).reverse())}let n=new B([...c][0],f);return Array.isArray(s)?(n.args[0].having=m.and(r(...s.map(o=>n.row[o]))),n.args[0].optional=Object.fromEntries(s.map((o,a)=>[o,i?.[a]]))):(n.args[0].having=m.and(r(n.row)),n.args[0].optional=i),this.select(n)}async get(e,r,i){let s=Array.isArray(i)?i:i?.fields;return s=s?Object.fromEntries(s.map(f=>[f,!0])):i?.include,this.select(e,r,s).execute(i)}async eval(e,r,i){return this.select(e,i).execute(typeof r=="function"?r:()=>r)}async set(e,r,i){let s=typeof i=="function"?i:()=>i,f=this.select(e,r,null);if(typeof i=="function"&&(i=i(f.row)),A(f.model.primary).some(o=>o in i))throw new TypeError("cannot modify primary key");let n=Object.entries(f.model.fields).filter(([o,a])=>o in i&&a.relation).map(([o,a])=>[o,a.relation]);return n.length?await this.ensureTransaction(async o=>{let a=await o.get(e,r);f=o.select(e,r,null);let l=_(s(f.row),n.map(([p])=>p));l=f.model.format(l);for(let[p]of n)await Promise.all(a.map(y=>o.processRelationUpdate(e,y,p,s(y)[p])));return Object.keys(l).length===0?{}:await f._action("set",l).execute()}):(i=f.model.format(i),Object.keys(i).length===0?{}:f._action("set",i).execute())}async remove(e,r){return this.select(e,r,null)._action("remove").execute()}async create(e,r){let i=this.select(e);if(this.hasRelation(e,r))return this.ensureTransaction(s=>s.createOrUpdate(e,r,!1));{let{primary:s,autoInc:f}=i.model;if(!f&&A(s).some(n=>g(r,n)===void 0))throw new Error("missing primary key");return i._action("create",i.model.create(r)).execute()}}async upsert(e,r,i){let s=this.select(e);return typeof r=="function"&&(r=r(s.row)),r=r.map(f=>s.model.format(f)),i=A(i||s.model.primary),s._action("upsert",r,i).execute()}makeProxy(e,r){let i=new Map,s=new Proxy(this,{get:$((f,c,n)=>c===e?!0:c!=="getDriver"?Reflect.get(f,c,n):o=>{let a=this.getDriver(o),l=i.get(a);return l||(l=r?.(a,s)??new Proxy(a,{get:$((p,y,b)=>y==="database"?s:Reflect.get(p,y,b),"get")}),i.set(a,l)),l},"get")});return s}withTransaction(e){return this.transact(e)}async transact(e){if(this[P.transact])throw new Error("nested transactions are not supported");let r=[],i=this.makeProxy(P.transact,c=>{let n=!1,o,a,l=new Promise(p=>a=p);return c=new Proxy(c,{get:$((p,y,b)=>y===P.transact?p:y==="database"?i:y==="session"?o:y==="_ensureSession"?()=>l:Reflect.get(p,y,b),"get")}),r.push(c.withTransaction(p=>(n&&(f=s()),n=!0,a(o=p),f))),c}),s=$(()=>Promise.resolve().then(()=>e(i)),"initialTaskFactory"),f=s();return f.catch(Ie).finally(()=>Promise.all(r))}async stopAll(){await Promise.all(this.drivers.splice(0,1/0).map(e=>e.stop()))}async drop(e){if(this[P.transact])throw new Error("cannot drop table in transaction");await this.getDriver(e).drop(e)}async dropAll(){if(this[P.transact])throw new Error("cannot drop table in transaction");await Promise.all(Object.values(this.drivers).map(e=>e.dropAll()))}async stats(){await this.prepared();let e={size:0,tables:{}};return await Promise.all(Object.values(this.drivers).map(async r=>{let{size:i=0,tables:s}=await r.stats();e.size+=i,Object.assign(e.tables,s)})),e}ensureTransaction(e){return this[P.transact]?e(this):this.transact(e)}transformRelationQuery(e,r,i,s){let f=this.tables[e].fields[i].relation,c=[];if(f.type==="oneToOne"||f.type==="manyToOne")s===null?c.push(m.nin(f.fields.map(n=>r[n]),this.select(f.table).evaluate(f.references))):c.push(m.in(f.fields.map(n=>r[n]),this.select(f.table,s).evaluate(f.references)));else if(f.type==="oneToMany")s.$or&&c.push(m.or(...s.$or.map(n=>this.transformRelationQuery(e,r,i,n).$expr))),s.$and&&c.push(...s.$and.map(n=>this.transformRelationQuery(e,r,i,n).$expr)),s.$not&&c.push(m.not(this.transformRelationQuery(e,r,i,s.$not).$expr)),s.$some&&c.push(m.in(f.fields.map(n=>r[n]),this.select(f.table,s.$some).evaluate(f.references))),s.$none&&c.push(m.nin(f.fields.map(n=>r[n]),this.select(f.table,s.$none).evaluate(f.references))),s.$every&&c.push(m.nin(f.fields.map(n=>r[n]),this.select(f.table,m.not(s.$every)).evaluate(f.references)));else if(f.type==="manyToMany"){let n=T.buildAssociationTable(e,f.table),o=f.fields.map(l=>T.buildAssociationKey(l,e)),a=f.references.map(l=>T.buildAssociationKey(l,f.table));if(s.$or&&c.push(m.or(...s.$or.map(l=>this.transformRelationQuery(e,r,i,l).$expr))),s.$and&&c.push(...s.$and.map(l=>this.transformRelationQuery(e,r,i,l).$expr)),s.$not&&c.push(m.not(this.transformRelationQuery(e,r,i,s.$not).$expr)),s.$some){let l=this.select(f.table,s.$some).evaluate(f.references),p=this.select(n,y=>m.in(a.map(b=>y[b]),l)).evaluate(o);c.push(m.in(f.fields.map(y=>r[y]),p))}if(s.$none){let l=this.select(f.table,s.$none).evaluate(f.references),p=this.select(n,y=>m.in(a.map(b=>y[b]),l)).evaluate(o);c.push(m.nin(f.fields.map(y=>r[y]),p))}if(s.$every){let l=this.select(f.table,m.not(s.$every)).evaluate(f.references),p=this.select(n,y=>m.in(a.map(b=>y[b]),l)).evaluate(o);c.push(m.nin(f.fields.map(y=>r[y]),p))}}return{$expr:m.and(...c)}}async createOrUpdate(e,r,i=!0){let s=this.select(e);r={...r};let f=[""];for(let c in r)if(r[c]!==void 0&&this.tables[e].fields[c]?.relation){let n=this.tables[e].fields[c].relation;n.type==="oneToOne"&&n.required?f.push(c):n.type==="oneToOne"?f.unshift(c):n.type==="oneToMany"?f.push(c):n.type==="manyToOne"?f.unshift(c):n.type==="manyToMany"&&f.push(c)}for(let c of[...f]){if(!c){let{primary:a,autoInc:l}=s.model,p=A(a);if(p.some(y=>Se(g(r,y))))if(l)delete r[a],i=!1;else throw new Error("missing primary key");i?await s._action("upsert",[s.model.format(_(r,f))],p).execute():Object.assign(r,await s._action("create",s.model.create(_(r,f))).execute());continue}let n=r[c],o=this.tables[e].fields[c].relation;if(o.type==="oneToOne"){if(n.$literal)r[c]=n.$literal,ue(f,c);else if(n.$create||!J(n)){let a=await this.createOrUpdate(o.table,{...Object.fromEntries(o.references.map((l,p)=>[l,g(r,o.fields[p])])),...n.$create??n});o.required||o.references.forEach((l,p)=>r[o.fields[p]]=g(a,l))}else if(n.$upsert)await this.upsert(o.table,[{...Object.fromEntries(o.references.map((a,l)=>[a,g(r,o.fields[l])])),...n.$upsert}]),o.required||o.references.forEach((a,l)=>r[o.fields[l]]=g(n.$upsert,a));else if(n.$connect)if(o.required)await this.set(o.table,n.$connect,Object.fromEntries(o.references.map((a,l)=>[a,g(r,o.fields[l])])));else{let a=o.references.every(l=>n.$connect[l]!==void 0)?[n.$connect]:await this.get(o.table,n.$connect);if(a.length!==1)throw new Error("related row not found or not unique");o.references.forEach((l,p)=>r[o.fields[p]]=g(a[0],l))}}else if(o.type==="manyToOne"){if(n.$literal)r[c]=n.$literal,ue(f,c);else if(n.$create||!J(n)){let a=await this.createOrUpdate(o.table,n.$create??n);o.references.forEach((l,p)=>r[o.fields[p]]=g(a,l))}else if(n.$upsert)await this.upsert(o.table,[n.$upsert]),o.references.forEach((a,l)=>r[o.fields[l]]=g(n.$upsert,a));else if(n.$connect){let a=o.references.every(l=>n.$connect[l]!==void 0)?[n.$connect]:await this.get(o.table,n.$connect);if(a.length!==1)throw new Error("related row not found or not unique");o.references.forEach((l,p)=>r[o.fields[p]]=g(a[0],l))}}else if(o.type==="oneToMany"){if(n.$create||Array.isArray(n))for(let a of A(n.$create??n))await this.createOrUpdate(o.table,{...Object.fromEntries(o.references.map((l,p)=>[l,g(r,o.fields[p])])),...a});n.$upsert&&await this.upsert(o.table,A(n.$upsert).map(a=>({...Object.fromEntries(o.references.map((l,p)=>[l,g(r,o.fields[p])])),...a}))),n.$connect&&await this.set(o.table,n.$connect,Object.fromEntries(o.references.map((a,l)=>[a,g(r,o.fields[l])])))}else if(o.type==="manyToMany"){let a=T.buildAssociationTable(o.table,e),l=o.fields.map(u=>T.buildAssociationKey(u,e)),p=o.references.map(u=>T.buildAssociationKey(u,o.table)),y=Object.entries(o.shared).map(([u,d])=>[T.buildSharedKey(u,d),{field:u,reference:d}]),b=[];if(n.$create||Array.isArray(n))for(let u of A(n.$create??n))b.push(await this.createOrUpdate(o.table,{...Object.fromEntries(y.map(([,d])=>[d.reference,g(u,d.reference)??g(r,d.field)])),...u}));if(n.$upsert){let u=A(n.$upsert).map(d=>({...Object.fromEntries(y.map(([,O])=>[O.reference,g(d,O.reference)??g(r,O.field)])),...d}));await this.upsert(o.table,u),b.push(...u)}if(n.$connect)for(let u of A(n.$connect))p.every(d=>u[d]!==void 0)?b.push(u):b.push(...await this.get(o.table,u));await this.upsert(a,b.map(u=>({...Object.fromEntries(y.map(([d,O])=>[d,g(u,O.reference)??g(r,O.field)])),...Object.fromEntries(l.map((d,O)=>[d,g(r,o.fields[O])])),...Object.fromEntries(p.map((d,O)=>[d,g(u,o.references[O])]))})))}}return r}async processRelationUpdate(e,r,i,s){let f=this.tables[e],c=Object.create(null),n=this.tables[e].fields[i].relation;if(n.type==="oneToOne"){if(s===null&&(s=n.required?{$remove:{}}:{$disconnect:{}}),typeof s=="object"&&!J(s)&&(s={$create:s}),s.$remove&&await this.remove(n.table,Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])]))),s.$disconnect&&(n.required?await this.set(n.table,k(Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])])),s.$disconnect),Object.fromEntries(n.references.map((o,a)=>[o,null]))):Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,null])))),(s.$set||typeof s=="function")&&await this.set(n.table,Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])])),s.$set??s),s.$create){let o=await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((a,l)=>[a,g(r,n.fields[l])])),...s.$create});n.required||Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,g(o,n.references[l])])))}if(s.$upsert&&(await this.upsert(n.table,A(s.$upsert).map(o=>({...Object.fromEntries(n.references.map((a,l)=>[a,g(r,n.fields[l])])),...o}))),n.required||Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,g(s.$upsert,n.references[a])])))),s.$connect)if(n.required)await this.set(n.table,s.$connect,Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])])));else{let o=await this.get(n.table,s.$connect);if(o.length!==1)throw new Error("related row not found or not unique");Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,g(o[0],n.references[l])])))}}else if(n.type==="manyToOne"){if(s===null&&(s={$disconnect:{}}),typeof s=="object"&&!J(s)&&(s={$create:s}),s.$remove&&await this.remove(n.table,Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])]))),s.$disconnect&&Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,null]))),(s.$set||typeof s=="function")&&await this.set(n.table,Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])])),s.$set??s),s.$create){let o=await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((a,l)=>[a,g(r,n.fields[l])])),...s.$create});Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,g(o,n.references[l])])))}if(s.$upsert&&(await this.upsert(n.table,A(s.$upsert).map(o=>({...Object.fromEntries(n.references.map((a,l)=>[a,g(r,n.fields[l])])),...o}))),Object.assign(c,Object.fromEntries(n.fields.map((o,a)=>[o,g(s.$upsert,n.references[a])])))),s.$connect){let o=await this.get(n.table,s.$connect);if(o.length!==1)throw new Error("related row not found or not unique");Object.assign(c,Object.fromEntries(n.fields.map((a,l)=>[a,g(o[0],n.references[l])])))}}else if(n.type==="oneToMany"){if(Array.isArray(s)){let o=[],a=[];s.forEach(l=>this.hasRelation(n.table,l)?o.push(l):a.push(l)),s={$remove:{},$create:o,$upsert:a}}if(s.$remove&&await this.remove(n.table,k(Object.fromEntries(n.references.map((o,a)=>[o,r[n.fields[a]]])),s.$remove)),s.$disconnect&&await this.set(n.table,k(Object.fromEntries(n.references.map((o,a)=>[o,g(r,n.fields[a])])),s.$disconnect),Object.fromEntries(n.references.map((o,a)=>[o,null]))),s.$set||typeof s=="function")for(let o of A(s.$set??s)){let[a,l]=o.update?[o.where,o.update]:[{},o];await this.set(n.table,k(Object.fromEntries(n.references.map((p,y)=>[p,r[n.fields[y]]])),a),l)}if(s.$create)for(let o of A(s.$create))await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((a,l)=>[a,g(r,n.fields[l])])),...o});s.$upsert&&await this.upsert(n.table,A(s.$upsert).map(o=>({...Object.fromEntries(n.references.map((a,l)=>[a,g(r,n.fields[l])])),...o}))),s.$connect&&await this.set(n.table,s.$connect,Object.fromEntries(n.references.map((o,a)=>[o,r[n.fields[a]]])))}else if(n.type==="manyToMany"){let o=T.buildAssociationTable(e,n.table),a=n.fields.map(y=>T.buildAssociationKey(y,e)),l=n.references.map(y=>T.buildAssociationKey(y,n.table)),p=Object.entries(n.shared).map(([y,b])=>[T.buildSharedKey(y,b),{field:y,reference:b}]);if(Array.isArray(s)){let y=[],b=[];s.forEach(u=>this.hasRelation(n.table,u)?y.push(u):b.push(u)),s={$disconnect:{},$create:y,$upsert:b}}if(s.$remove){let y=await this.select(o,{...Object.fromEntries(p.map(([b,u])=>[b,g(r,u.field)])),...Object.fromEntries(a.map((b,u)=>[b,g(r,n.fields[u])])),[n.table]:s.$remove},null).execute();await this.remove(o,b=>m.in([...p.map(([u,d])=>b[u]),...a.map(u=>b[u]),...l.map(u=>b[u])],y.map(u=>[...p.map(([d,O])=>g(u,d)),...a.map(d=>g(u,d)),...l.map(d=>g(u,d))]))),await this.remove(n.table,b=>m.in([...p.map(([u,d])=>b[d.reference]),...n.references.map(u=>b[u])],y.map(u=>[...p.map(([d,O])=>g(u,d)),...l.map(d=>g(u,d))])))}if(s.$disconnect){let y=await this.select(o,{...Object.fromEntries(p.map(([b,u])=>[b,g(r,u.field)])),...Object.fromEntries(a.map((b,u)=>[b,g(r,n.fields[u])])),[n.table]:s.$disconnect},null).execute();await this.remove(o,b=>m.in([...p.map(([u,d])=>b[u]),...a.map(u=>b[u]),...l.map(u=>b[u])],y.map(u=>[...p.map(([d,O])=>g(u,d)),...a.map(d=>g(u,d)),...l.map(d=>g(u,d))])))}if(s.$set)for(let y of A(s.$set)){let[b,u]=y.update?[y.where,y.update]:[{},y],d=await this.select(o,O=>({...Object.fromEntries(p.map(([w,x])=>[w,g(r,x.field)])),...Object.fromEntries(a.map((w,x)=>[w,g(r,n.fields[x])])),[n.table]:b}),null).execute();await this.set(n.table,O=>m.in([...p.map(([w,x])=>O[x.reference]),...n.references.map(w=>O[w])],d.map(w=>[...p.map(([x,K])=>g(w,x)),...l.map(x=>g(w,x))])),u)}if(s.$create){let y=[];for(let b of A(s.$create))y.push(await this.createOrUpdate(n.table,{...Object.fromEntries(n.references.map((u,d)=>[u,g(r,n.fields[d])])),...b}));await this.upsert(o,y.map(b=>({...Object.fromEntries(p.map(([u,d])=>[u,g(r,d.field)])),...Object.fromEntries(a.map((u,d)=>[u,r[n.fields[d]]])),...Object.fromEntries(l.map((u,d)=>[u,b[n.references[d]]]))})))}if(s.$upsert&&(await this.upsert(n.table,A(s.$upsert).map(y=>({...Object.fromEntries(n.references.map((b,u)=>[b,g(r,n.fields[u])])),...y}))),await this.upsert(o,A(s.$upsert).map(y=>({...Object.fromEntries(p.map(([b,u])=>[b,g(r,u.field)])),...Object.fromEntries(a.map((b,u)=>[b,r[n.fields[u]]])),...Object.fromEntries(l.map((b,u)=>[b,y[n.references[u]]]))})))),s.$connect){let y=await this.get(n.table,k(Object.fromEntries(p.map(([b,u])=>[u.reference,g(r,u.field)])),s.$connect));await this.upsert(o,y.map(b=>({...Object.fromEntries(p.map(([u,d])=>[u,g(r,d.field)])),...Object.fromEntries(a.map((u,d)=>[u,r[n.fields[d]]])),...Object.fromEntries(l.map((u,d)=>[u,b[n.references[d]]]))})))}}Object.keys(c).length&&await this.set(e,Me(f.format(r),A(f.primary)),c)}hasRelation(e,r){for(let i in r)if(r[i]!==void 0&&this.tables[e].fields[i]?.relation)return!0;return!1}},ct=class{constructor(t,e){this.ctx=t,this.config=e,this.database=t.model,this.logger=t.logger(this.constructor.name),t.on("ready",async()=>{await Promise.resolve(),await this.start(),t.model.drivers.push(this),t.model.refresh();let r=Object.create(t.model);Je(r,"ctx",t),r._driver=this,r[Ge.tracker]={associate:"database",property:"ctx"},t.set("database",Le.associate(r,"database"))}),t.on("dispose",async()=>{He(t.model.drivers,this),await this.stop()})}static{$(this,"Driver")}static inject=["model"];database;logger;types=Object.create(null);model(t){if(typeof t=="string"){let r=this.database.tables[t];if(r)return r;throw new TypeError(`unknown table name "${t}"`)}if(B.is(t)){if(!t.args[0].fields&&(typeof t.table=="string"||B.is(t.table)))return t.model;let r=new oe("temp");return t.args[0].fields?r.fields=$e(t.args[0].fields,i=>({type:h.fromTerm(i)})):r.fields=$e(t.model.fields,i=>({type:h.fromField(i)})),r}let e=new oe("temp");for(let r in t){let i=this.model(t[r]);for(let s in i.fields)E.available(i.fields[s])&&(e.fields[`${r}.${s}`]={expr:m("",[t[r].ref,s],h.fromField(i.fields[s])),type:h.fromField(i.fields[s])})}return e}async migrate(t,e){let r=this.database.makeProxy(we.migrate),i=this.model(t);await(r.migrateTasks[t]=Promise.resolve(r.migrateTasks[t]).then(()=>Promise.all([...i.migrations].map(async([s,f])=>{try{if(!e.before(f))return;await s(r),e.after(f)}catch(c){e.error(c)}}))).then(e.finalize).catch(e.error))}define(t){t.types.forEach(e=>this.types[e]=t)}async _ensureSession(){}async prepareIndexes(t){let e=await this.getIndexes(t),{indexes:r}=this.model(t);for(let i of r){let s=e.find(f=>f.name===i.name);s?ze(s,i)||(await this.dropIndex(t,i.name),await this.createIndex(t,i)):await this.createIndex(t,i)}}},lt=class Ee extends Error{constructor(e,r){super(r||e.replace("-"," ")),this.code=e}static{$(this,"RuntimeError")}name="RuntimeError";static check(e,r){return e instanceof Ee?!r||e.message===r:!1}},ge={$or:$((t,e)=>t.reduce((r,i)=>r||Q(i,e),!1),"$or"),$and:$((t,e)=>t.reduce((r,i)=>r&&Q(i,e),!0),"$and"),$not:$((t,e)=>!Q(t,e),"$not"),$exists:$((t,e)=>t!==ae(e),"$exists"),$eq:$((t,e)=>e.valueOf()===t.valueOf(),"$eq"),$ne:$((t,e)=>e.valueOf()!==t.valueOf(),"$ne"),$gt:$((t,e)=>e.valueOf()>t.valueOf(),"$gt"),$gte:$((t,e)=>e.valueOf()>=t.valueOf(),"$gte"),$lt:$((t,e)=>e.valueOf()<t.valueOf(),"$lt"),$lte:$((t,e)=>e.valueOf()<=t.valueOf(),"$lte"),$in:$((t,e)=>t.includes(e),"$in"),$nin:$((t,e)=>!t.includes(e),"$nin"),$regex:$((t,e)=>V(t).test(e),"$regex"),$regexFor:$((t,e)=>typeof t=="string"?V(e).test(t):V(e,t.flags).test(t.input),"$regexFor"),$bitsAllSet:$((t,e)=>(t&e)===t,"$bitsAllSet"),$bitsAllClear:$((t,e)=>(t&e)===0,"$bitsAllClear"),$bitsAnySet:$((t,e)=>(t&e)!==0,"$bitsAnySet"),$bitsAnyClear:$((t,e)=>(t&e)!==t,"$bitsAnyClear"),$el:$((t,e)=>e.some(r=>Q(t,r)),"$el"),$size:$((t,e)=>e.length===t,"$size")};function Q(t,e){if(Array.isArray(t))return t.includes(e);if(t instanceof RegExp)return t.test(e);if(Z(t))return e.valueOf()===t.valueOf();if(ae(t))return ae(e);for(let r in t)if(r in ge&&!ge[r](t[r],e))return!1;return!0}$(Q,"executeFieldQuery");function G(t,e,r,i={}){return Object.entries(e).every(([f,c])=>{if(f==="$and")return c.reduce((n,o)=>n&&G(t,o,r,i),!0);if(f==="$or")return c.reduce((n,o)=>n||G(t,o,r,i),!1);if(f==="$not")return!G(t,c,r,i);if(f==="$expr")return j({...i,[r]:t,_:t},c);try{let n=C(e[f])?{[f]:e[f]}:pe(e[f],`${f}.`);return Object.entries(n).every(([o,a])=>Q(a,g(t,o)))}catch{return!1}})}$(G,"executeQuery");var dt=Symbol("minato.types"),bt=Symbol("minato.tables"),$t=we;export{m as $,we as Database,ct as Driver,m as Eval,E as Field,ut as Logger,oe as Model,T as Relation,lt as RuntimeError,ht as Schema,B as Selection,bt as Tables,h as Type,dt as Types,$t as default,j as executeEval,G as executeQuery,Ce as executeSort,De as executeUpdate,pe as flatten,g as getCell,H as hasSubquery,je as isAggrExpr,Z as isComparable,W as isEmpty,M as isEvalExpr,C as isFlat,J as isUpdateExpr,V as makeRegExp,ce as randomId,le as unravel,yt as z};
